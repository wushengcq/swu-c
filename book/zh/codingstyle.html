
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>9. 编码风格 &mdash; akabook 3.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="akabook 3.0 documentation" href="../index.html" />
    <link rel="up" title="中文版：Linux C/C++编程一站式学习" href="index.html" />
    <link rel="next" title="10. gdb" href="gdb.html" />
    <link rel="prev" title="8. 数组" href="array.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="gdb.html" title="10. gdb"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="array.html" title="8. 数组"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">akabook 3.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">中文版：Linux C/C++编程一站式学习</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>9. 编码风格<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>代码风格好不好就像字写得好不好看一样，如果一个公司招聘秘书，肯定不要字写得难看的，同理，代码风格糟糕的程序员肯定也是不称职的。虽然编译器不会挑剔难看的代码，照样能编译通过，但是和你一个Team的其他程序员肯定受不了，你自己也受不了，写完代码几天之后再来看，自己都不知道自己写的是什么。 <a class="reference internal" href="bibli.html#sicp" id="id2">[SICP]</a> 的第一版前言里有句话说得好：“Thus, programs must be written for people to read, and only incidentally for machines to execute.”代码主要是为了写给人看的，而不是写给机器看的，只是顺便也能用机器执行而已，如果是为了写给机器看那直接写机器指令就好了，没必要用高级语言了。代码和语言文字一样是为了表达思想、记载信息，所以一定要写得清楚整洁才能有效地表达。</p>
<p>在一个软件项目中，代码风格一般都用文档规定死了，所有参与项目的人不管他自己原来是什么风格，都要遵守统一的风格，例如Linux内核的 <a class="reference internal" href="bibli.html#codingstyle" id="id3">[CodingStyle]</a> 就是这样一个文档。本章我们以内核的代码风格为基础来讲解好的编码风格都有哪些规定，这些规定的Rationale是什么。我只是以Linux内核为例来讲解编码风格的概念，并没有说内核编码风格就一定是最好的编码风格，但Linux内核项目如此成功，就足以说明它的编码风格是最好的C语言编码风格之一了。</p>
<div class="section" id="codingstyle-indent">
<span id="id4"></span><h2>9.1. 缩进和空白<a class="headerlink" href="#codingstyle-indent" title="Permalink to this headline">¶</a></h2>
<p>我们知道C语言的语法对缩进和空白没有要求，空格、Tab、换行都可以随意写，实现同样功能的代码可以写得很好看，也可以写得很难看。例如 <a class="reference internal" href="array.html#array-multidim"><span>多维数组</span></a> 的“剪刀石头布”代码如果写成这样就很难看了：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">char</span> <span class="n">gesture</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;scissor&quot;</span><span class="p">,</span><span class="s">&quot;stone&quot;</span><span class="p">,</span><span class="s">&quot;cloth&quot;</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">man</span><span class="p">,</span><span class="n">computer</span><span class="p">,</span><span class="n">result</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
<span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
<span class="n">computer</span><span class="o">=</span><span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="mi">3</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Input your gesture (0-scissor 1-stone 2-cloth):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">ret</span><span class="o">=</span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">man</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">ret</span><span class="o">!=</span><span class="mi">1</span><span class="o">||</span><span class="n">man</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">||</span><span class="n">man</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">){</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Invalid input!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;You: %s</span><span class="se">\t</span><span class="s">Computer: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">gesture</span><span class="p">[</span><span class="n">man</span><span class="p">],</span><span class="n">gesture</span><span class="p">[</span><span class="n">computer</span><span class="p">]);</span>
<span class="n">result</span><span class="o">=</span><span class="p">(</span><span class="n">man</span><span class="o">-</span><span class="n">computer</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;You win!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Draw!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;You lose!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>一是缺少空白字符，代码密度太大，看着很费劲。二是没有缩进，看不出来哪个{和哪个}配对，像这么短的代码还能凑合着看，如果代码超过一屏就完全没法看了。 <a class="reference internal" href="bibli.html#codingstyle" id="id5">[CodingStyle]</a> 中关于空白字符并没有特别规定，因为基本上所有的C代码风格对于空白字符的规定都差不多，主要有以下几条。</p>
<ol class="arabic">
<li><p class="first">关键字 <code class="docutils literal"><span class="pre">if</span></code> 、 <code class="docutils literal"><span class="pre">while</span></code> 、 <code class="docutils literal"><span class="pre">for</span></code> 与其后的控制表达式的(括号之间插入一个空格分隔，但括号内的表达式应紧贴括号。例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre>while␣(1);
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">双目运算符的两侧各插入一个空格分隔，单目运算符和操作数之间不加空格，例如 <code class="docutils literal"><span class="pre">i␣=␣i␣+␣1</span></code> 、 <code class="docutils literal"><span class="pre">++i</span></code> 、 <code class="docutils literal"><span class="pre">!(i␣&lt;␣1)</span></code> 、 <code class="docutils literal"><span class="pre">-x</span></code> 、 <code class="docutils literal"><span class="pre">&amp;a</span></code> 等。</p>
</li>
<li><p class="first">后缀运算符和操作数之间也不加空格，例如取结构体成员 <code class="docutils literal"><span class="pre">s.a</span></code> 、函数调用 <code class="docutils literal"><span class="pre">foo(arg1)</span></code> 、取数组成员 <code class="docutils literal"><span class="pre">a[i]</span></code> 。</p>
</li>
<li><p class="first">,号和;号之后要加空格，这是英文的书写习惯，例如 <code class="docutils literal"><span class="pre">for␣(i␣=␣1;␣i␣&lt;␣10;␣i++)</span></code> 、 <code class="docutils literal"><span class="pre">foo(arg1,␣arg2)</span></code> 。</p>
</li>
<li><p class="first">以上关于加空格的规则并没有严格要求，有时为了突出优先级也可以写得更紧凑一些，例如 <code class="docutils literal"><span class="pre">for␣(i=1;␣i&lt;10;␣i++)</span></code> 、 <code class="docutils literal"><span class="pre">distance␣=␣sqrt(x*x␣+␣y*y)</span></code> 等。但是省略的空格一定不要误导了读代码的人，例如 <code class="docutils literal"><span class="pre">a||b␣&amp;&amp;␣c</span></code> 很容易让人理解成错误的优先级。</p>
</li>
<li><p class="first">由于UNIX系统标准的字符终端是24行80列的，接近或大于80个字符的较长语句或声明要折行写，折行后用空格和上面的表达式或参数对齐，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre>if␣(sqrt(x*x␣+␣y*y)␣&gt;␣5.0
    &amp;&amp;␣x␣&lt;␣0.0
    &amp;&amp;␣y␣&gt;␣0.0)
</pre></div>
</td></tr></table></div>
<p>再比如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre>foo(sqrt(x*x␣+␣y*y),
    a[i-1]␣+␣b[i-1]␣+␣c[i-1])
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">较长的字符串可以断成多个字符串然后分行书写，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is such a long sentence that &quot;</span>
       <span class="s">&quot;it cannot be held within a line</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>C编译器会自动把相邻的多个字符串接在一起，以上两个字符串相当于一个字符串 <code class="docutils literal"><span class="pre">&quot;This</span> <span class="pre">is</span> <span class="pre">such</span> <span class="pre">a</span> <span class="pre">long</span> <span class="pre">sentence</span> <span class="pre">that</span> <span class="pre">it</span> <span class="pre">cannot</span> <span class="pre">be</span> <span class="pre">held</span> <span class="pre">within</span> <span class="pre">a</span> <span class="pre">line\n&quot;</span></code> 。注意这个语法有时候会带来一点麻烦，比如下面这段代码在语法上没有问题，但在语义上有问题，你能看出是什么问题吗？</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">char</span> <span class="n">days</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;Monday&quot;</span><span class="p">,</span> <span class="s">&quot;Tuesday&quot;</span>
                     <span class="s">&quot;Wednesday&quot;</span><span class="p">,</span> <span class="s">&quot;Thursday&quot;</span><span class="p">,</span> <span class="s">&quot;Friday&quot;</span>
                     <span class="s">&quot;Saturday&quot;</span><span class="p">,</span> <span class="s">&quot;Sunday&quot;</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">有的人喜欢在变量定义中使用Tab字符，使变量名对齐，这样看起来很美观。</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre>int    →a, b;
double →c;
</pre></div>
</td></tr></table></div>
</li>
</ol>
<p>内核代码风格关于缩进和空白的规则有以下几条。</p>
<ol class="arabic">
<li><p class="first">要用缩进体现出语句块的层次关系，使用Tab字符缩进，不能用空格代替Tab。在标准的字符终端上一个Tab看起来是8个空格的宽度，如果你的文本编辑器可以设置一个Tab的显示宽度是几个空格，建议也设成8，这样大的缩进使代码看起来非常清晰。如果有的行用空格做缩进，有的行用Tab做缩进，甚至空格和Tab混用，那么一旦改变了文本编辑器的Tab显示宽度就会看起来非常混乱，所以内核代码风格规定只能用Tab做缩进，不能用空格代替Tab。</p>
</li>
<li><p class="first">在 <code class="docutils literal"><span class="pre">if/else</span></code> 、 <code class="docutils literal"><span class="pre">while</span></code> 、 <code class="docutils literal"><span class="pre">do/while</span></code> 、 <code class="docutils literal"><span class="pre">for</span></code> 、 <code class="docutils literal"><span class="pre">switch</span></code> 这些可以带语句块的语句中，语句块的{或}应该和关键字写在同一行，用空格隔开，而不是单独占一行。这个规定和 [K&amp;R]_ 的代码风格一致，好处是不必占太多行，使得一屏能显示更多代码。例如应该这样写：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre>if␣(...)␣{
       →语句列表
}␣else␣if␣(...)␣{
       →语句列表
}
</pre></div>
</td></tr></table></div>
<p>但很多人还是习惯这样写：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre>if␣(...)
{
       →语句列表
}
else␣if␣(...)
{
       →语句列表
}
</pre></div>
</td></tr></table></div>
<p>这两种写法用得都很广泛，只要在同一个项目中能保持统一就可以了。</p>
</li>
<li><p class="first">函数定义的{和}单独占一行，这一点和语句块的规定不同，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre>int␣foo(int␣a,␣int␣b)
{
       →语句列表
}
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">switch</span></code> 和语句块里的 <code class="docutils literal"><span class="pre">case</span></code> 、 <code class="docutils literal"><span class="pre">default</span></code> 对齐写，也就是说语句块里的 <code class="docutils literal"><span class="pre">case</span></code> 、 <code class="docutils literal"><span class="pre">default</span></code> 标号相对于 <code class="docutils literal"><span class="pre">switch</span></code> 不往里缩进，但标号下的语句要往里缩进。例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre>switch␣(c)␣{
case &#39;A&#39;:
       →语句列表
case &#39;B&#39;:
       →语句列表
default:
       →语句列表
}
</pre></div>
</td></tr></table></div>
<p>用于 <code class="docutils literal"><span class="pre">goto</span></code> 语句的自定义标号应该顶头写不缩进，而不管标号下的语句缩进到第几层。</p>
</li>
<li><p class="first">代码中每个逻辑段落之间应该用一个空行分隔开。例如每个函数定义之间应该插入一个空行，头文件、全局变量定义和函数定义之间也应该插入空行，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int g;
double h;

int foo(void)
{
       →语句列表
}

int bar(int a)
{
       →语句列表
}

int main(void)
{
       →语句列表
}
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">如果一个函数的语句列表很长，可以根据相关性分成若干组，用空行分隔，通常把变量定义组成一组，后面加空行， <code class="docutils literal"><span class="pre">return</span></code> 语句之前加空行，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre>int main(void)
{
       →int    →a, b;
       →double →c;

       →语句组1

       →语句组2

       →return 0;
}
</pre></div>
</td></tr></table></div>
</li>
</ol>
</div>
<div class="section" id="id6">
<h2>9.2. 注释<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>单行注释应采用 <code class="docutils literal"><span class="pre">/*␣comment␣*/</span></code> 的形式，用空格把界定符和文字分开。多行注释最常见的是这种形式：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">␣*␣Multi-line</span>
<span class="cm">␣*␣comment</span>
<span class="cm">␣*/</span>
</pre></div>
</td></tr></table></div>
<p>也有更花哨的形式：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*************\</span>
<span class="cm">* Multi-line  *</span>
<span class="cm">* comment     *</span>
<span class="cm">\*************/</span>
</pre></div>
</td></tr></table></div>
<p>使用注释的场合主要有以下几种。</p>
<ol class="arabic">
<li><p class="first">整个源文件的顶部注释。说明此模块的相关信息，例如文件名、作者和版本历史等，顶头写不缩进。例如内核源代码目录下的 <code class="file docutils literal"><span class="pre">kernel/sched.c</span></code> 文件的开头：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  kernel/sched.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Kernel scheduler and related syscalls</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991-2002  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and</span>
<span class="cm"> *              make semaphores SMP safe</span>
<span class="cm"> *  1998-11-19  Implemented schedule_timeout() and related stuff</span>
<span class="cm"> *              by Andrea Arcangeli</span>
<span class="cm"> *  2002-01-04  New ultra-scalable O(1) scheduler by Ingo Molnar:</span>
<span class="cm"> *              hybrid priority-list and round-robin design with</span>
<span class="cm"> *              an array-switch method of distributing timeslices</span>
<span class="cm"> *              and per-CPU runqueues.  Cleanups and useful suggestions</span>
<span class="cm"> *              by Davide Libenzi, preemptible kernel bits by Robert Love.</span>
<span class="cm"> *  2003-09-03  Interactivity tuning by Con Kolivas.</span>
<span class="cm"> *  2004-04-02  Scheduler domains code by Nick Piggin</span>
<span class="cm"> */</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">函数注释。说明此函数的功能、参数、返回值、错误码等，写在函数定义上侧，和此函数定义之间不留空行，顶头写不缩进。</p>
</li>
<li><p class="first">相对独立的语句组注释。对这一组语句做特别说明，写在语句组上侧，和此语句组之间不留空行，与当前语句组的缩进一致。</p>
</li>
<li><p class="first">代码行右侧的简短注释。对当前代码行做特别说明，一般为单行注释，和代码之间至少用一个空格隔开，一个源文件中所有的右侧注释最好能上下对齐。尽管 <a class="reference internal" href="expr.html#expr-helloworld"><span>继续Hello World</span></a> 讲过注释可以穿插在一行代码中间，但不建议这么写。内核源代码目录下的 <code class="file docutils literal"><span class="pre">lib/radix-tree.c</span></code> 文件中的一个函数包含了上述三种注释：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> *      radix_tree_insert    -    insert into a radix tree</span>
<span class="cm"> *      @root:          radix tree root</span>
<span class="cm"> *      @index:         index key</span>
<span class="cm"> *      @item:          item to insert</span>
<span class="cm"> *</span>
<span class="cm"> *      Insert an item into the radix tree at position @index.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">radix_tree_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
                        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">radix_tree_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="n">shift</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

        <span class="cm">/* Make sure the tree is high enough.  */</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">index</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rnode</span><span class="p">)</span> <span class="o">||</span>
                        <span class="n">index</span> <span class="o">&gt;</span> <span class="n">radix_tree_maxindex</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">radix_tree_extend</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">slot</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">rnode</span><span class="p">;</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">RADIX_TREE_MAP_SHIFT</span><span class="p">;</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                     <span class="cm">/* uninitialised var warning */</span>
        <span class="k">do</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                        <span class="cm">/* Have to add a child node.  */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">slot</span> <span class="o">=</span> <span class="n">radix_tree_node_alloc</span><span class="p">(</span><span class="n">root</span><span class="p">)))</span>
                                <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
                                <span class="n">node</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
                                <span class="n">node</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
                        <span class="p">}</span> <span class="k">else</span>
                                <span class="n">root</span><span class="o">-&gt;</span><span class="n">rnode</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="cm">/* Go a level down */</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RADIX_TREE_MAP_MASK</span><span class="p">;</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
                <span class="n">slot</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>
                <span class="n">shift</span> <span class="o">-=</span> <span class="n">RADIX_TREE_MAP_SHIFT</span><span class="p">;</span>
                <span class="n">height</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">height</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>

        <span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">);</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">BUG_ON</span><span class="p">(</span><span class="n">tag_get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
        <span class="n">BUG_ON</span><span class="p">(</span><span class="n">tag_get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference internal" href="bibli.html#codingstyle" id="id7">[CodingStyle]</a> 中特别指出，函数内的注释要尽可能少用。写注释主要是为了说明你的代码“能做什么”（比如函数接口定义），而不是为了说明“怎样做”，只要代码写得足够清晰，“怎样做”是一目了然的，如果你需要用注释才能解释清楚，那就表示你的代码可读性很差，除非是特别需要提醒注意的地方才使用函数内注释。</p>
</li>
<li><p class="first">复杂的结构体定义比函数更需要注释。例如内核源代码目录下的 <code class="file docutils literal"><span class="pre">kernel/sched.c</span></code> 文件中定义了这样一个结构体：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This is the main, per-CPU runqueue data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking rule: those places that want to lock multiple runqueues</span>
<span class="cm"> * (such as the load balancing or the thread migration code), lock</span>
<span class="cm"> * acquire operations must be ordered by ascending &amp;runqueue.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">runqueue</span> <span class="p">{</span>
        <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * nr_running and cpu_load should be in the same cacheline because</span>
<span class="cm">         * remote CPUs use both these fields when doing load calculation.</span>
<span class="cm">         */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_running</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu_load</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="cp">#endif</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">nr_switches</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * This is part of a global counter where only the total sum</span>
<span class="cm">         * over all CPUs matters. A task can increase this counter on</span>
<span class="cm">         * one CPU and if it got migrated afterwards it may decrease</span>
<span class="cm">         * it on another CPU. Always updated under the runqueue lock:</span>
<span class="cm">         */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_uninterruptible</span><span class="p">;</span>

        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expired_timestamp</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">timestamp_last_tick</span><span class="p">;</span>
        <span class="n">task_t</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">idle</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">prev_mm</span><span class="p">;</span>
        <span class="n">prio_array_t</span> <span class="o">*</span><span class="n">active</span><span class="p">,</span> <span class="o">*</span><span class="n">expired</span><span class="p">,</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">best_expired_prio</span><span class="p">;</span>
        <span class="n">atomic_t</span> <span class="n">nr_iowait</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
        <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

        <span class="cm">/* For active balancing */</span>
        <span class="kt">int</span> <span class="n">active_balance</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">push_cpu</span><span class="p">;</span>

        <span class="n">task_t</span> <span class="o">*</span><span class="n">migration_thread</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">migration_queue</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
        <span class="cm">/* latency stats */</span>
        <span class="k">struct</span> <span class="n">sched_info</span> <span class="n">rq_sched_info</span><span class="p">;</span>

        <span class="cm">/* sys_sched_yield() stats */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">yld_exp_empty</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">yld_act_empty</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">yld_both_empty</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">yld_cnt</span><span class="p">;</span>

        <span class="cm">/* schedule() stats */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sched_switch</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sched_cnt</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sched_goidle</span><span class="p">;</span>

        <span class="cm">/* try_to_wake_up() stats */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ttwu_cnt</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ttwu_local</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">复杂的宏定义和变量声明也需要注释。例如内核源代码目录下的 <code class="file docutils literal"><span class="pre">include/linux/jiffies.h</span></code> 文件中的声明和注释：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* TICK_USEC_TO_NSEC is the time between ticks in nsec assuming real ACTHZ and  */</span>
<span class="cm">/* a value TUSEC for TICK_USEC (can be set bij adjtimex)                */</span>
<span class="cp">#define TICK_USEC_TO_NSEC(TUSEC) (SH_DIV (TUSEC * USER_HZ * 1000, ACTHZ, 8))</span>

<span class="cm">/* some arch&#39;s have a small-data section that can be accessed register-relative</span>
<span class="cm"> * but that can only take up to, say, 4-byte variables. jiffies being part of</span>
<span class="cm"> * an 8-byte variable may not be correctly accessed unless we force the issue</span>
<span class="cm"> */</span>
<span class="cp">#define __jiffy_data  __attribute__((section(&quot;.data&quot;)))</span>

<span class="cm">/*</span>
<span class="cm"> * The 64-bit value is not volatile - you MUST NOT read it</span>
<span class="cm"> * without sampling the sequence number in xtime_lock.</span>
<span class="cm"> * get_jiffies_64() will do this for you as appropriate.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">__jiffy_data</span> <span class="n">jiffies_64</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">volatile</span> <span class="n">__jiffy_data</span> <span class="n">jiffies</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</li>
</ol>
</div>
<div class="section" id="id8">
<h2>9.3. 标识符命名<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>标识符命名应遵循以下原则：</p>
<ol class="arabic simple" id="index-0">
<li>标识符命名要清晰明了，可以使用完整的单词和易于理解的缩写。短的单词可以通过去元音形成缩写，较长的单词可以取单词的头几个字母形成缩写。看别人的代码看多了就可以总结出一些缩写惯例，例如 <code class="docutils literal"><span class="pre">count</span></code> 写成 <code class="docutils literal"><span class="pre">cnt</span></code> ， <code class="docutils literal"><span class="pre">block</span></code> 写成 <code class="docutils literal"><span class="pre">blk</span></code> ， <code class="docutils literal"><span class="pre">length</span></code> 写成 <code class="docutils literal"><span class="pre">len</span></code> ， <code class="docutils literal"><span class="pre">window</span></code> 写成 <code class="docutils literal"><span class="pre">win</span></code> ， <code class="docutils literal"><span class="pre">message</span></code> 写成 <code class="docutils literal"><span class="pre">msg</span></code> ， <code class="docutils literal"><span class="pre">number</span></code> 写成 <code class="docutils literal"><span class="pre">nr</span></code> ， <code class="docutils literal"><span class="pre">temporary</span></code> 可以写成 <code class="docutils literal"><span class="pre">temp</span></code> ，也可以进一步写成 <code class="docutils literal"><span class="pre">tmp</span></code> ，最有意思的是 <code class="docutils literal"><span class="pre">internationalization</span></code> 写成 <code class="docutils literal"><span class="pre">i18n</span></code> （因为i和n中间省略了18个字母），词根 <code class="docutils literal"><span class="pre">trans</span></code> 经常缩写成 <code class="docutils literal"><span class="pre">x</span></code> （例如 <code class="docutils literal"><span class="pre">transmit</span></code> 写成 <code class="docutils literal"><span class="pre">xmt</span></code> ）。我就不多举例了，请读者在看代码时自己注意总结和积累。</li>
<li>内核编码风格规定变量、函数和类型采用全小写加下划线的方式命名，常量（比如宏定义和枚举常量）采用全大写加下划线的方式命名，比如上一节举例的函数名 <code class="docutils literal"><span class="pre">radix_tree_insert</span></code> 、类型名 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">radix_tree_root</span></code> 、常量名 <code class="docutils literal"><span class="pre">RADIX_TREE_MAP_SHIFT</span></code> 等。</li>
<li>微软发明了一种变量命名法叫匈牙利命名法（Hungarian Notation），在变量名中用前缀表示类型，例如 <code class="docutils literal"><span class="pre">iCnt</span></code> （i表示int）、 <code class="docutils literal"><span class="pre">pMsg</span></code> （p表示pointer）、 <code class="docutils literal"><span class="pre">lpszText</span></code> （lpsz表示long pointer to a null-terminated string）等。Linus在 <a class="reference internal" href="bibli.html#codingstyle" id="id9">[CodingStyle]</a> 中毫不客气地讽刺了这种写法：“Encoding the type of a function into the name (so-called Hungarian notation) is brain damaged - the compiler knows the types anyway and can check those, and it only confuses the programmer. No wonder MicroSoft makes buggy programs.”代码风格本来就是一个很有争议的问题，如果你接受本章介绍的内核编码风格，就不要使用大小写混合的变量命名方式 <a class="footnote-reference" href="#id11" id="id10">[1]</a> ，更不要使用匈牙利命名法。</li>
<li>全局变量和全局函数的命名一定要详细，不惜多用几个单词多写几个下划线，例如函数名 <code class="docutils literal"><span class="pre">radix_tree_insert</span></code> ，因为它们在整个项目的许多源文件中都会用到，必须让使用者明确这个变量或函数是干什么用的。局部变量和只在一个源文件中调用的内部函数的命名可以简略一些，但不能太短。尽量不要使用单个字母做变量名，只有一个例外：用 <code class="docutils literal"><span class="pre">i</span></code> 、 <code class="docutils literal"><span class="pre">j</span></code> 、 <code class="docutils literal"><span class="pre">k</span></code> 做循环变量是可以的。</li>
<li>针对中国程序员的一条特别规定：禁止用汉语拼音做标识符，可读性极差。</li>
</ol>
<span class="target" id="index-1"></span><table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[1]</a></td><td>大小写混合的命名方式是Modern C++风格所提倡的，在C++代码中很普遍，称为CamelCase，大概是因为有高有低像驼峰一样。</td></tr>
</tbody>
</table>
</div>
<div class="section" id="id12">
<h2>9.4. 函数<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>每个函数都应该设计得尽可能简单，简单的函数才容易维护。应遵循以下原则：</p>
<ol class="arabic simple" id="index-2">
<li>实现一个函数只是为了做好一件事情，不要把函数设计成用途广泛、面面俱到的，这样的函数肯定会超长，而且往往不可重用，维护困难。</li>
<li>函数内部的缩进层次不宜过多，一般以少于4层为宜。如果缩进层次太多就说明设计得太复杂了，应考虑分割成更小的函数（Helper Function）来调用。</li>
<li>函数不要写得太长，建议在24行的标准终端上不超过两屏，太长会造成阅读困难，如果一个函数超过两屏就应该考虑分割函数了。 <a class="reference internal" href="bibli.html#codingstyle" id="id13">[CodingStyle]</a> 中特别说明，如果一个函数在概念上是简单的，只是长度很长，这倒没关系。例如函数由一个大的 <code class="docutils literal"><span class="pre">switch</span></code> 组成，其中有非常多的 <code class="docutils literal"><span class="pre">case</span></code> ，这是可以的，因为各 <code class="docutils literal"><span class="pre">case</span></code> 分支互不影响，整个函数的复杂度只等于其中一个 <code class="docutils literal"><span class="pre">case</span></code> 的复杂度，这种情况很常见，例如TCP协议的状态机实现。</li>
<li>执行函数就是执行一个动作，函数名通常应包含动词，例如 <code class="docutils literal"><span class="pre">get_current</span></code> 、 <code class="docutils literal"><span class="pre">radix_tree_insert</span></code> 。</li>
<li>比较重要的函数定义上侧必须加注释，说明此函数的功能、参数、返回值、错误码等。</li>
<li>另一种度量函数复杂度的办法是看有多少个局部变量，5到10个局部变量已经很多了，再多就很难维护了，应该考虑分割成多个函数。</li>
</ol>
</div>
<div class="section" id="indent">
<h2>9.5. indent工具<a class="headerlink" href="#indent" title="Permalink to this headline">¶</a></h2>
<p><strong class="command">indent</strong> 工具可以把代码格式化成某种风格，例如把 <a class="reference internal" href="#codingstyle-indent"><span>缩进和空白</span></a> 中缺少缩进和空白“剪刀石头布”代码格式化成内核编码风格:</p>
<div class="highlight-python"><div class="highlight"><pre>$ indent -kr -i8 main.c
$ cat main.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
int main(void)
{
        char gesture[3][10] = { &quot;scissor&quot;, &quot;stone&quot;, &quot;cloth&quot; };
        int man, computer, result, ret;
        srand(time(NULL));
        while (1) {
                computer = rand() % 3;
                printf
                    (&quot;\nInput your gesture (0-scissor 1-stone 2-cloth):\n&quot;);
                ret = scanf(&quot;%d&quot;, &amp;man);
                if (ret != 1 || man &lt; 0 || man &gt; 2) {
                        printf(&quot;Invalid input!\n&quot;);
                        return 1;
                }
                printf(&quot;You: %s\tComputer: %s\n&quot;,
                       gesture[man], gesture[computer]);
                result = (man - computer + 4) % 3 - 1;
                if (result &gt; 0)
                        printf(&quot;You win!\n&quot;);
                else if (result == 0)
                        printf(&quot;Draw!\n&quot;);
                else
                        printf(&quot;You lose!\n&quot;);
        }
        return 0;
}
</pre></div>
</div>
<p><code class="xref std std-option docutils literal"><span class="pre">-kr</span></code> 选项表示K&amp;R风格， <code class="xref std std-option docutils literal"><span class="pre">-i8</span></code> 表示缩进8个空格的长度。如果没有指定 <code class="xref std std-option docutils literal"><span class="pre">-nut</span></code> 选项，则每8个缩进空格会自动用一个Tab代替。注意 <strong class="command">indent</strong> 命令会直接修改原文件，而不是打印到屏幕上或者输出到另一个文件，这一点和很多UNIX命令不同。可以看出， <code class="xref std std-option docutils literal"><span class="pre">-kr</span> <span class="pre">-i8</span></code> 两个选项格式化出来的代码已经很符合本章介绍的代码风格了，添加了必要的缩进和空白，较长的代码行也会自动折行。美中不足的是没有添加适当的空行，因为 <strong class="command">indent</strong> 工具也不知道哪几行代码在逻辑上是一组的，空行还是要自己动手添，当然原有的空行肯定不会被 <strong class="command">indent</strong> 删去的。</p>
<p>如果你采纳本章介绍的内核编码风格，基本上 <code class="xref std std-option docutils literal"><span class="pre">-kr</span> <span class="pre">-i8</span></code> 这两个参数就够用了。 <strong class="command">indent</strong> 工具也有支持其他编码风格的选项，具体请参阅 <em class="manpage">indent(1)</em> 。有时候 <strong class="command">indent</strong> 工具的确非常有用，比如某个项目中途决定改变编码风格（这很少见），或者往某个项目中添加的几个代码文件来自另一个编码风格不同的项目，但绝不能因为有了 <strong class="command">indent</strong> 工具就肆无忌惮，一开始把代码写得乱七八糟，最后再依靠 <strong class="command">indent</strong> 去清理。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">9. 编码风格</a><ul>
<li><a class="reference internal" href="#codingstyle-indent">9.1. 缩进和空白</a></li>
<li><a class="reference internal" href="#id6">9.2. 注释</a></li>
<li><a class="reference internal" href="#id8">9.3. 标识符命名</a></li>
<li><a class="reference internal" href="#id12">9.4. 函数</a></li>
<li><a class="reference internal" href="#indent">9.5. indent工具</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="array.html"
                        title="previous chapter">8. 数组</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="gdb.html"
                        title="next chapter">10. gdb</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/zh/codingstyle.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><table border=0 cellspacing=0 style="color: white;">
<script type="text/javascript">
  //<![CDATA[
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34437927-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
  //]]>
</script>
<tr><td>
   请输入您的email订阅<a href="http://groups.google.com/group/learning-linux-c-cpp">本书的邮件列表</a><br/>
   (Please enter your email to subscribe to <a href="http://groups.google.com/group/learning-linux-c-cpp">this book's mailing list</a>)<br/>
   <form action="http://groups.google.com/group/learning-linux-c-cpp/boxsubscribe"><input type=text name=email><input type=submit name="sub" value="订阅(Subscribe)"></form>
</td></tr>

<tr><td><br/>关注<a href="http://weibo.com/sansoong">我的微博</a></td></tr>

<tr><td><br/>Checkout the source from github: <a href="https://github.com/learning-linux-c-cpp/akabook">https://github.com/learning-linux-c-cpp/akabook</a></td></tr>

<tr><td>
   <br/>感谢您的慷慨捐赠！<br/>
   Thanks for your generous donation!<br/>
   <a href="http://me.alipay.com/songjinshan" target="_blank"><img src="/akabook/_static/me.alipay.png" alt="捐赠"></a>
</td></tr>
</table>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="gdb.html" title="10. gdb"
             >next</a> |</li>
        <li class="right" >
          <a href="array.html" title="8. 数组"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">akabook 3.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >中文版：Linux C/C++编程一站式学习</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, Sean Soong.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>