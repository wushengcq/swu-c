
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6. 循环语句 &mdash; akabook 3.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="akabook 3.0 documentation" href="../index.html" />
    <link rel="up" title="中文版：Linux C/C++编程一站式学习" href="index.html" />
    <link rel="next" title="7. 结构体" href="struct.html" />
    <link rel="prev" title="5. 深入理解函数" href="func2.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="struct.html" title="7. 结构体"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="func2.html" title="5. 深入理解函数"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">akabook 3.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">中文版：Linux C/C++编程一站式学习</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>6. 循环语句<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="while">
<span id="iter-while"></span><h2>6.1. while语句<a class="headerlink" href="#while" title="Permalink to this headline">¶</a></h2>
<p id="index-0">在 <a class="reference internal" href="func2.html#func2-recurse"><span>递归</span></a> 中，我们介绍了用递归求n!的方法，其实每次递归调用都在重复做同一件事，就是把n乘到(n-1)!上然后把结果返回。虽说是重复，但每次做都稍微有一点区别（n的值不一样），这种每次都有一点区别的重复工作称为迭代（Iteration）。我们使用计算机的主要目的之一就是让它做重复迭代的工作，因为把一件工作重复做成千上万次而不出错正是计算机最擅长的，也是人最不擅长的。虽然迭代用递归来做就够了，但C语言提供了循环语句使迭代程序写起来更方便。例如 <code class="docutils literal"><span class="pre">factorial</span></code> 用 <code class="docutils literal"><span class="pre">while</span></code> 语句可以写成：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>和 <code class="docutils literal"><span class="pre">if</span></code> 语句类似， <code class="docutils literal"><span class="pre">while</span></code> 语句由一个控制表达式和一个子语句组成，子语句可以是由若干条语句和声明组成的语句块:</p>
<div class="highlight-python"><div class="highlight"><pre>语句 → while (控制表达式) 语句
</pre></div>
</div>
<p id="index-1">如果控制表达式的值为真，子语句就被执行，然后再次测试控制表达式的值，如果还是真，就把子语句再执行一遍，再测试控制表达式的值……这种控制流程称为循环（Loop），子语句称为循环体。如果某次测试控制表达式的值为假，就跳出循环执行后面的 <code class="docutils literal"><span class="pre">return</span></code> 语句，如果第一次测试控制表达式的值就是假，那么直接跳到 <code class="docutils literal"><span class="pre">return</span></code> 语句，循环体一次都不执行。</p>
<p id="index-2">变量 <code class="docutils literal"><span class="pre">result</span></code> 在这个循环中的作用是累加器（Accumulator），把每次循环的中间结果累积起来，循环结束后得到的累积值就是最终结果，由于这个例子是用乘法来累积的，所以 <code class="docutils literal"><span class="pre">result</span></code> 的初值是1，如果用加法累积则 <code class="docutils literal"><span class="pre">result</span></code> 的初值应该是0。变量 <code class="docutils literal"><span class="pre">n</span></code> 是循环变量（Loop Variable），对于每次循环，在循环体中都要改变它的值，在控制表达式中都要测试它的值，这两点合起来起到控制循环次数的作用，在这个例子中 <code class="docutils literal"><span class="pre">n</span></code> 的值是递减的，也有些循环采用递增的循环变量。这个例子有一定的典型性，累加器和循环变量这两种模式在循环中都很常见。</p>
<p>可见，递归能解决的问题用循环也能解决，但解决问题的思路不一样。用递归解决这个问题靠的是递推关系n!=n·(n-1)!，用循环解决这个问题则更像是把这个公式展开了：n!=n·(n-1)·(n-2)·…·3·2·1。把公式展开了理解会更直观一些，所以有些时候循环程序比递归程序更容易理解。但也有一些公式要展开是非常复杂甚至是不可能的，反倒是递推关系更直观一些，这种情况下递归程序比循环程序更容易理解。</p>
<p id="index-3">这个例子的递归和循环解法还有一点不同：看 <a class="reference internal" href="func2.html#func2-factorial"><span>factorial(3)的调用过程</span></a> ，在整个递归调用过程中，虽然分配和释放了很多变量，但所有变量都只在初始化时赋值，没有任何变量的值发生过改变，而上面的循环程序则通过对 <code class="docutils literal"><span class="pre">n</span></code> 和 <code class="docutils literal"><span class="pre">result</span></code> 这两个变量多次赋值来达到同样的目的。前一种思路称为函数式编程（Functional Programming），而后一种思路称为命令式编程（Imperative Programming）。函数式编程的“函数”类似于数学函数的概念，回顾一下 <a class="reference internal" href="func.html#func-mathfunc"><span>数学函数</span></a> 所讲的，数学函数是没有Side Effect的，而C语言的函数可以有Side Effect，比如在一个函数中修改某个全局变量的值就是一种Side Effect。在 <a class="reference internal" href="func.html#func-scope"><span>作用域</span></a> 讲过全局变量被多次赋值会给调试带来困难，如果一个函数体很长，控制流程很复杂，那么局部变量被多次赋值也会有同样的问题。因此，不要以为“变量可以多次赋值”是天经地义的，有很多编程语言可以完全采用函数式编程的方式，避免Side Effect，例如LISP、Haskell、Erlang等。用C语言编程主要还是采用Imperative的方式，但要记住， <strong>给变量多次赋值时要格外小心，在代码中多次读写同一变量应该以一种一致的方式进行</strong> 。所谓“一致的方式”是说应该有一套统一的规则，规定在一段代码中哪里会对某个全局变量赋值、哪里会读取它的值，比如在 <a class="reference internal" href="stdlib.html#stdlib-errno"><span>errno与perror/strerror函数</span></a> 会讲到访问 <code class="docutils literal"><span class="pre">errno</span></code> 的规则。</p>
<p id="index-4">递归函数如果写得不小心就会变成无穷递归，同样道理，循环如果写得不小心就会变成无限循环（Infinite Loop）或者叫死循环。如果 <code class="docutils literal"><span class="pre">while</span></code> 语句的控制表达式永远为真就成了一个死循环，例如 <code class="docutils literal"><span class="pre">while</span> <span class="pre">(1)</span> <span class="pre">{...}</span></code> 。在写循环时要小心检查你写的控制表达式有没有可能取值为假，除非你故意写死循环（有的时候这是必要的）。在上面的例子中，不管 <code class="docutils literal"><span class="pre">n</span></code> 一开始是几，每次循环都会把 <code class="docutils literal"><span class="pre">n</span></code> 减掉1， <code class="docutils literal"><span class="pre">n</span></code> 越来越小最后必然等于0，所以控制表达式最后必然取值为假，但如果把 <code class="docutils literal"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">-</span> <span class="pre">1;</span></code> 这句漏掉就成了死循环。有时候是不是死循环并不是那么一目了然，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>如果 <code class="docutils literal"><span class="pre">n</span></code> 为正整数，这个循环能跳出来吗？循环体所做的事情是：如果 <code class="docutils literal"><span class="pre">n</span></code> 是偶数，就把 <code class="docutils literal"><span class="pre">n</span></code> 除以2，如果 <code class="docutils literal"><span class="pre">n</span></code> 是奇数，就把 <code class="docutils literal"><span class="pre">n</span></code> 乘3加1。一般来说循环变量要么递增要么递减，可是这个例子中的 <code class="docutils literal"><span class="pre">n</span></code> 一会儿变大一会儿变小，最终会不会变成1呢？可以找个数试试，例如一开始 <code class="docutils literal"><span class="pre">n</span></code> 等于7，每次循环后 <code class="docutils literal"><span class="pre">n</span></code> 的值依次是：7、22、11、34、17、52、26、13、40、20、10、5、16、8、4、2、1－－最后 <code class="docutils literal"><span class="pre">n</span></code> 确实等于1了。读者可以再试几个数都是如此，但无论试多少个数也不能代替证明，这个循环有没有可能对某些正整数 <code class="docutils literal"><span class="pre">n</span></code> 是死循环呢？其实这个例子只是给读者提提兴趣，同时提醒读者写循环时要有意识地检查控制表达式。至于这个循环有没有可能是死循环，这是著名的3x+1问题，目前世界上还无人能证明。许多世界难题都是这样的：问题的描述无比简单，连小学生都能看懂，但证明却无比困难。</p>
<p class="rubric">习题</p>
<ol class="arabic">
<li><p class="first">用循环解决 <a class="reference internal" href="func2.html#func2-recurse"><span>递归</span></a> 的习题，体会递归和循环这两种不同的思路。</p>
</li>
<li><p class="first">编写程序数一下1到100的所有整数中出现多少次数字9。在写程序之前先把这些问题考虑清楚：
#. 这个问题中的循环变量是什么？
#. 这个问题中的累加器是什么？用加法还是用乘法累积？
#. 在 <a class="reference internal" href="cond.html#cond-ifelse"><span>if/else语句</span></a> 的习题中写过取一个整数的个位和十位的表达式，这两个表达式怎样用到本程序中？</p>
</li>
<li><p class="first">下面的循环语句执行结果是什么？</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</li>
</ol>
</div>
<div class="section" id="do-while">
<h2>6.2. do/while语句<a class="headerlink" href="#do-while" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">do/while</span></code> 语句的语法是:</p>
<div class="highlight-python"><div class="highlight"><pre>语句 → do 语句 while (控制表达式);
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">while</span></code> 语句先测试控制表达式的值再执行循环体，而 <code class="docutils literal"><span class="pre">do/while</span></code> 语句先执行循环体再测试控制表达式的值。如果控制表达式的值一开始就是假， <code class="docutils literal"><span class="pre">while</span></code> 语句的循环体一次都不执行，而 <code class="docutils literal"><span class="pre">do/while</span></code> 语句的循环体仍然要执行一次再跳出循环。其实只要有 <code class="docutils literal"><span class="pre">while</span></code> 循环就足够了， <code class="docutils literal"><span class="pre">do/while</span></code> 循环和后面要讲的 <code class="docutils literal"><span class="pre">for</span></code> 循环都可以改写成 <code class="docutils literal"><span class="pre">while</span></code> 循环，只不过有些情况下用 <code class="docutils literal"><span class="pre">do/while</span></code> 或 <code class="docutils literal"><span class="pre">for</span></code> 循环写起来更简便，代码更易读。</p>
<p>上一节的 <code class="docutils literal"><span class="pre">factorial</span></code> 函数也可以改用 <code class="docutils literal"><span class="pre">do/while</span></code> 循环来写：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">do</span> <span class="p">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>写循环一定要注意循环即将结束时控制表达式的临界条件是否准确，上面的循环控制条件如果写成 <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">n</span></code> 就错了，当 <code class="docutils literal"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">n</span></code> 时跳出循环，最后的结果中就少乘了一个 <code class="docutils literal"><span class="pre">n</span></code> 。虽然变量名应该尽可能起得有意义一些，不过用 <code class="docutils literal"><span class="pre">i</span></code> 、 <code class="docutils literal"><span class="pre">j</span></code> 、 <code class="docutils literal"><span class="pre">k</span></code> 给循环变量起名倒是很常见的。</p>
</div>
<div class="section" id="for">
<h2>6.3. for语句<a class="headerlink" href="#for" title="Permalink to this headline">¶</a></h2>
<p>前两节我们在 <code class="docutils literal"><span class="pre">while</span></code> 和 <code class="docutils literal"><span class="pre">do/while</span></code> 循环中使用循环变量，其实使用循环变量最常见的是 <code class="docutils literal"><span class="pre">for</span></code> 循环这种形式。 <code class="docutils literal"><span class="pre">for</span></code> 语句的语法是:</p>
<div class="highlight-python"><div class="highlight"><pre>语句 → for (控制表达式1; 控制表达式2; 控制表达式3) 语句
</pre></div>
</div>
<p>如果不考虑循环体中包含 <code class="docutils literal"><span class="pre">continue</span></code> 语句的情况（稍后介绍 <code class="docutils literal"><span class="pre">continue</span></code> 语句），这个 <code class="docutils literal"><span class="pre">for</span></code> 循环等价于下面的 <code class="docutils literal"><span class="pre">while</span></code> 循环:</p>
<div class="highlight-python"><div class="highlight"><pre>控制表达式1;
while (控制表达式2) {
        语句
        控制表达式3;
}
</pre></div>
</div>
<p>从这种等价形式来看，控制表达式1和3都可以为空，但控制表达式2是必不可少的，例如 <code class="docutils literal"><span class="pre">for</span> <span class="pre">(;1;)</span> <span class="pre">{...}</span></code> 等价于 <code class="docutils literal"><span class="pre">while</span> <span class="pre">(1)</span> <span class="pre">{...}</span></code> 死循环。C语言规定，如果控制表达式2为空，则认为控制表达式2的值为真，因此死循环也可以写成 <code class="docutils literal"><span class="pre">for</span> <span class="pre">(;;)</span> <span class="pre">{...}</span></code> 。</p>
<p>上一节 <code class="docutils literal"><span class="pre">do/while</span></code> 循环的例子可以改写成 <code class="docutils literal"><span class="pre">for</span></code> 循环：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p id="index-5">其中 <code class="docutils literal"><span class="pre">++i</span></code> 这个表达式相当于 <code class="docutils literal"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></code> <a class="footnote-reference" href="#id4" id="id2">[1]</a> ，++称为前缀自增运算符（Prefix Increment Operator）。类似地，&#8211;称为前缀自减运算符（Prefix Decrement Operator） <a class="footnote-reference" href="#id5" id="id3">[2]</a> ， <code class="docutils literal"><span class="pre">--i</span></code> 相当于 <code class="docutils literal"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">-</span> <span class="pre">1</span></code> 。如果把 <code class="docutils literal"><span class="pre">++i</span></code> 这个表达式看作一个函数调用，除了传入一个参数 <code class="docutils literal"><span class="pre">i</span></code> 返回一个值（返回值等于参数值加1）之外，还产生一个Side Effect，就是把变量 <code class="docutils literal"><span class="pre">i</span></code> 的值增加了1。</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>这两种写法在语义上稍有区别，详见 <a class="reference internal" href="op.html#op-compoundassign"><span>复合赋值运算符</span></a> 。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>increment和decrement这两个词很有意思，大多数字典都说它们是名词，但经常被当成动词用，在计算机术语中，它们当动词用应该理解为increase by one和decrease by one。现代英语中很多原本是名词的都被当成动词用，字典都跟不上时代了，再比如transition也是如此。</td></tr>
</tbody>
</table>
<p id="index-6">++和 ‐‐ 运算符也可以用在变量后面，例如 <code class="docutils literal"><span class="pre">i++</span></code> 和 <code class="docutils literal"><span class="pre">i--</span></code> ，为了和前缀运算符区别，这两个运算符称为后缀自增运算符（Postfix Increment Operator）和后缀自减运算符（Postfix Decrement Operator）。如果把 <code class="docutils literal"><span class="pre">i++</span></code> 这个表达式看作一个函数调用，传入一个参数 <code class="docutils literal"><span class="pre">i</span></code> 返回一个值，返回值就等于参数值（而不是参数值加1），此外也产生一个Side Effect，就是把变量 <code class="docutils literal"><span class="pre">i</span></code> 的值增加了1，它和 <code class="docutils literal"><span class="pre">++i</span></code> 的区别就在于返回值不同。同理， <code class="docutils literal"><span class="pre">--i</span></code> 返回 <code class="docutils literal"><span class="pre">i</span></code> 减1之后的值，而 <code class="docutils literal"><span class="pre">i--</span></code> 返回 <code class="docutils literal"><span class="pre">i</span></code> 减1之前的值，但这两个表达式都产生同样的Side Effect，就是把变量 <code class="docutils literal"><span class="pre">i</span></code> 的值减了1。</p>
<p>使用++和 ‐‐ 运算符会使程序更加简洁，但也会影响程序的可读性， [K&amp;R]_ 中的示例代码大量运用++、 ‐‐ 和其他表达式的组合使得代码非常简洁。为了让初学者循序渐进，在接下来的几章中++、 ‐‐ 运算符总是单独组成一个表达式而不跟其他表达式组合，从 <a class="reference internal" href="sortsearch.html"><em>排序与查找</em></a> 开始将采用 [K&amp;R]_ 的简洁风格。</p>
<p>我们看一个有意思的问题： <code class="docutils literal"><span class="pre">a+++++b</span></code> 这个表达式如何理解？应该理解成 <code class="docutils literal"><span class="pre">a++</span> <span class="pre">++</span> <span class="pre">+b</span></code> 还是 <code class="docutils literal"><span class="pre">a++</span> <span class="pre">+</span> <span class="pre">++b</span></code> ，还是 <code class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">++</span> <span class="pre">++b</span></code> 呢？应该按第一种方式理解。编译的过程分为词法解析、语法解析、语义检查三个阶段，我们分别来分析：</p>
<ol class="arabic simple">
<li>在词法解析阶段，编译器总是从前到后找最长的合法Token。把这个表达式从前到后解析，变量名 <code class="docutils literal"><span class="pre">a</span></code> 是一个Token， <code class="docutils literal"><span class="pre">a</span></code> 后面有两个以上的+号，在C语言中一个+号是合法的Token（可以是加法运算符或正号），两个+号也是合法的Token（可以是自增运算符），根据最长匹配原则，编译器绝不会止步于一个+号，而一定会把两个+号当作一个Token。</li>
<li>再往后解析仍然有两个以上的+号，所以又是一个++运算符。</li>
<li>再往后解析只剩一个+号了，是加法运算符。</li>
<li>再往后解析是变量名 <code class="docutils literal"><span class="pre">b</span></code> 。</li>
<li>词法解析之后进入下一阶段语法解析， <code class="docutils literal"><span class="pre">a</span></code> 是一个表达式， <code class="docutils literal"><span class="pre">表达式++</span></code> 还是表达式， 再 <code class="docutils literal"><span class="pre">表达式++</span></code> 还是表达式，再 <code class="docutils literal"><span class="pre">表达式+b</span></code> 还是表达式，语法上没有问题。</li>
<li>最后编译器会做一些基本的语义检查，这时就有问题了：++运算符要求操作数能做左值， <code class="docutils literal"><span class="pre">a</span></code> 能做左值所以 <code class="docutils literal"><span class="pre">a++</span></code> 没问题，但表达式 <code class="docutils literal"><span class="pre">a++</span></code> 的值只能做右值，不能再++了，所以最终编译器会报错。</li>
</ol>
<p>C99规定了一种新的 <code class="docutils literal"><span class="pre">for</span></code> 循环语法（其实是从C++借鉴的），在“控制表达式1”的位置可以有变量定义。例如上例的循环变量 <code class="docutils literal"><span class="pre">i</span></code> 可以只在 <code class="docutils literal"><span class="pre">for</span></code> 循环中定义：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>如果这样定义，那么变量 <code class="docutils literal"><span class="pre">i</span></code> 只是 <code class="docutils literal"><span class="pre">for</span></code> 循环中的局部变量而不是整个函数的局部变量，相当于 <a class="reference internal" href="cond.html#cond-if"><span>if语句</span></a> 讲过的语句块中的局部变量，在循环结束后就不能再使用 <code class="docutils literal"><span class="pre">i</span></code> 这个变量了，注意这个程序用 <strong class="command">gcc</strong> 编译时必须加上选项 <code class="xref std std-option docutils literal"><span class="pre">-std=c99</span></code> <a class="footnote-reference" href="#id7" id="id6">[3]</a> 。</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[3]</a></td><td>本书介绍的C99新特性有很多是不需要在编译时加 <code class="xref std std-option docutils literal"><span class="pre">-std=c99</span></code> 选项的，例如在 <a class="reference internal" href="expr.html#expr-helloworld"><span>继续Hello World</span></a> 讲过的C++风格的 <code class="docutils literal"><span class="pre">//</span></code> 注释，还有在 <a class="reference internal" href="func.html#func-deffunction"><span>定义自己的函数</span></a> 讲过的“在函数体内语句和声明可以按任意顺序排列”，使用这些特性的代码在编译时都不需要加 <code class="xref std std-option docutils literal"><span class="pre">-std=c99</span></code> 选项，这是为什么呢？因为C标准更新得太慢，有些新特性在C99标准还没出来之前 <strong class="command">gcc</strong> 就已经实现了，有些已经存在了好多年了，所以在 <strong class="command">gcc</strong> 看来这不算什么新特性，没什么好大惊小怪的。</td></tr>
</tbody>
</table>
</div>
<div class="section" id="breakcontinue">
<h2>6.4. break和continue语句<a class="headerlink" href="#breakcontinue" title="Permalink to this headline">¶</a></h2>
<p id="index-7">在 <a class="reference internal" href="cond.html#cond-switch"><span>switch语句</span></a> 中我们见到了 <code class="docutils literal"><span class="pre">break</span></code> 语句的一种用法，用来跳出 <code class="docutils literal"><span class="pre">switch</span></code> 语句块，这个语句也可以用来跳出循环体。 <code class="docutils literal"><span class="pre">continue</span></code> 语句也会终止当前循环，和 <code class="docutils literal"><span class="pre">break</span></code> 语句不同的是， <code class="docutils literal"><span class="pre">continue</span></code> 语句终止当前循环后又回到循环体的开头准备执行下一次循环。对于 <code class="docutils literal"><span class="pre">while</span></code> 循环和 <code class="docutils literal"><span class="pre">do/while</span></code> 循环，执行 <code class="docutils literal"><span class="pre">continue</span></code> 语句之后测试控制表达式，如果值为真则继续执行下一次循环；对于 <code class="docutils literal"><span class="pre">for</span></code> 循环，执行 <code class="docutils literal"><span class="pre">continue</span></code> 语句之后首先计算“控制表达式3”，然后测试“控制表达式2”，如果值为真则继续执行下一次循环。例如下面的代码打印1到100之间的素数（Prime）：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">is_prime</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">break</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                        <span class="k">continue</span><span class="p">;</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><code class="docutils literal"><span class="pre">is_prime</span></code> 函数从2到 <code class="docutils literal"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">1</span></code> 依次检查有没有能被 <code class="docutils literal"><span class="pre">n</span></code> 整除的数，如果有就说明 <code class="docutils literal"><span class="pre">n</span></code> 不是素数，立刻跳出循环而不执行 <code class="docutils literal"><span class="pre">i++</span></code> 。因此，如果 <code class="docutils literal"><span class="pre">n</span></code> 不是素数，则循环结束后 <code class="docutils literal"><span class="pre">i</span></code> 一定小于 <code class="docutils literal"><span class="pre">n</span></code> ，如果 <code class="docutils literal"><span class="pre">n</span></code> 是素数，则循环结束后 <code class="docutils literal"><span class="pre">i</span></code> 一定等于 <code class="docutils literal"><span class="pre">n</span></code> 。注意检查临界条件：2应该是素数，如果 <code class="docutils literal"><span class="pre">n</span></code> 是2，则循环体一次也不执行，但 <code class="docutils literal"><span class="pre">i</span></code> 的初值就是2，也等于 <code class="docutils literal"><span class="pre">n</span></code> ，在程序中也判定为素数。其实没有必要从2一直检查到n-1，只要从2检查到⌊sqrt(n)⌋，如果全都不能整除就足以证明n是素数了，请读者想一想为什么。</p>
<p>在主程序中，从1到100依次检查每个数是不是素数，如果不是素数，并不直接跳出循环，而是 <code class="docutils literal"><span class="pre">i++</span></code> 后继续执行下一次循环，因此用 <code class="docutils literal"><span class="pre">continue</span></code> 语句。注意主程序的局部变量 <code class="docutils literal"><span class="pre">i</span></code> 和 <code class="docutils literal"><span class="pre">is_prime</span></code> 中的局部变量 <code class="docutils literal"><span class="pre">i</span></code> 是不同的两个变量，其实在调用 <code class="docutils literal"><span class="pre">is_prime</span></code> 函数时主程序的局部变量 <code class="docutils literal"><span class="pre">i</span></code> 和 <code class="docutils literal"><span class="pre">is_prime</span></code> 函数的参数 <code class="docutils literal"><span class="pre">n</span></code> 的值相等。</p>
<p class="rubric">习题</p>
<ol class="arabic simple">
<li>求素数这个程序只是为了说明 <code class="docutils literal"><span class="pre">break</span></code> 和 <code class="docutils literal"><span class="pre">continue</span></code> 的用法才这么写的，其实完全可以不用 <code class="docutils literal"><span class="pre">break</span></code> 和 <code class="docutils literal"><span class="pre">continue</span></code> ，请读者修改一下控制流程，去掉 <code class="docutils literal"><span class="pre">break</span></code> 和 <code class="docutils literal"><span class="pre">continue</span></code> 而保持功能不变。</li>
<li>上一节讲过怎样把 <code class="docutils literal"><span class="pre">for</span></code> 循环改写成等价的 <code class="docutils literal"><span class="pre">while</span></code> 循环，但也提到如果循环体中有 <code class="docutils literal"><span class="pre">continue</span></code> 语句这两种形式就不等价了，想一想为什么不等价了？</li>
</ol>
</div>
<div class="section" id="id8">
<h2>6.5. 嵌套循环<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>上一节求素数的例子在循环中调用一个函数，而那个函数里面又有一个循环，这其实是一种嵌套循环。如果把那个函数的代码拿出来写就更清楚了：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                                <span class="k">break</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>现在内循环的循环变量就不能再用 <code class="docutils literal"><span class="pre">i</span></code> 了，而是改用 <code class="docutils literal"><span class="pre">j</span></code> ，原来程序中 <code class="docutils literal"><span class="pre">is_prime</span></code> 函数的参数 <code class="docutils literal"><span class="pre">n</span></code> 现在直接用 <code class="docutils literal"><span class="pre">i</span></code> 代替。在有多层循环或 <code class="docutils literal"><span class="pre">switch</span></code> 嵌套的情况下， <code class="docutils literal"><span class="pre">break</span></code> 只能跳出最内层的循环或 <code class="docutils literal"><span class="pre">switch</span></code> ， <code class="docutils literal"><span class="pre">continue</span></code> 也只能终止最内层循环并回到该层循环的开头。</p>
<p>用循环也可以打印表格式的数据，比如打印小九九乘法表：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="mi">9</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d  &quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="p">);</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>内循环每次打印一个数，数与数之间用两个空格隔开，外循环每次打印一行。结果如下:</p>
<div class="highlight-python"><div class="highlight"><pre>1  2  3  4  5  6  7  8  9
2  4  6  8  10  12  14  16  18
3  6  9  12  15  18  21  24  27
4  8  12  16  20  24  28  32  36
5  10  15  20  25  30  35  40  45
6  12  18  24  30  36  42  48  54
7  14  21  28  35  42  49  56  63
8  16  24  32  40  48  56  64  72
9  18  27  36  45  54  63  72  81
</pre></div>
</div>
<p>由于乘法结果有一位数的也有两位数的，这个表格很不整齐，如果把打印语句改为 <code class="docutils literal"><span class="pre">printf(&quot;%d\t&quot;,</span> <span class="pre">i*j);</span></code> 就整齐了，Tab字符（制表符）就是这样得名的。</p>
<p class="rubric">习题</p>
<ol class="arabic">
<li><p class="first">本节打印小九九的例子打印出来的结果有一半数据是重复的，比如8×9跟9×8的结果一样。请修改程序打印这样的小九九:</p>
<div class="highlight-python"><div class="highlight"><pre>1
2       4
3       6       9
4       8       12      16
5       10      15      20      25
6       12      18      24      30      36
7       14      21      28      35      42      49
8       16      24      32      40      48      56      64
9       18      27      36      45      54      63      72      81
</pre></div>
</div>
</li>
<li><p class="first">编写函数 <code class="docutils literal"><span class="pre">diamond</span></code> 打印一个菱形。如果调用 <code class="docutils literal"><span class="pre">diamond(3,</span> <span class="pre">'*')</span></code> 则打印:</p>
<div class="highlight-python"><div class="highlight"><pre>        *
*       *       *
        *
</pre></div>
</div>
<p>如果调用 <code class="docutils literal"><span class="pre">diamond(5,</span> <span class="pre">'+')</span></code> 则打印:</p>
<div class="highlight-python"><div class="highlight"><pre>                +
        +       +       +
+       +       +       +       +
        +       +       +
                +
</pre></div>
</div>
<p>如果用偶数做参数则打印错误提示。</p>
</li>
</ol>
</div>
<div class="section" id="goto">
<h2>6.6. goto语句和标号<a class="headerlink" href="#goto" title="Permalink to this headline">¶</a></h2>
<p>分支、循环都讲完了，还剩下最后一种影响控制流程的语句没讲，就是 <code class="docutils literal"><span class="pre">goto</span></code> 语句，实现无条件跳转。我们知道 <code class="docutils literal"><span class="pre">break</span></code> 只能跳出最内层的循环，如果在一个嵌套循环中遇到某个错误条件需要立即跳出最外层循环做出错处理，就可以用 <code class="docutils literal"><span class="pre">goto</span></code> 语句，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre>for (...)
        for (...) {
                ...
                if (出现错误条件)
                        goto error;
        }
error:
        出错处理;
</pre></div>
</td></tr></table></div>
<p id="index-8">这里的 <code class="docutils literal"><span class="pre">error:</span></code> 叫做标号（Label），任何语句前面都可以加若干个标号，标号的命名也要遵循标识符的命名规则。</p>
<p><code class="docutils literal"><span class="pre">goto</span></code> 语句过于强大了，从程序中的任何地方都可以无条件跳转到任何其他地方，只要在那个地方定义一个标号就行，唯一的限制是 <code class="docutils literal"><span class="pre">goto</span></code> 只能跳转到同一个函数中的某个标号处，而不能跳到别的函数中 <a class="footnote-reference" href="#id10" id="id9">[4]</a> 。 <strong>滥用 ``goto`` 语句会使程序的控制流程非常复杂，可读性很差。</strong> 著名的计算机科学家Edsger W. Dijkstra最早指出编程语言中 <code class="docutils literal"><span class="pre">goto</span></code> 语句的危害，提倡取消 <code class="docutils literal"><span class="pre">goto</span></code> 语句。 <code class="docutils literal"><span class="pre">goto</span></code> 语句不是必须存在的，显然可以用别的办法替代，比如上面的代码段可以改写为：</p>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[4]</a></td><td>C标准库函数 <code class="docutils literal"><span class="pre">setjmp</span></code> 和 <code class="docutils literal"><span class="pre">longjmp</span></code> 配合起来可以实现函数间的跳转，但只能从被调用的函数跳回到它的直接或间接调用者（同时从栈空间弹出一个或多个栈帧），而不能从一个函数跳转到另一个和它毫不相干的函数中。 <code class="docutils literal"><span class="pre">setjmp/longjmp</span></code> 函数主要也是用于出错处理，比如函数A调用函数B，函数B调用函数C，如果在C中出现某个错误条件，使得函数B和C继续执行下去都没有意义了，可以利用 <code class="docutils literal"><span class="pre">setjmp/longjmp</span></code> 机制快速返回到函数A做出错处理，本书不详细介绍这种机制，有兴趣的读者可参考 <a class="reference internal" href="bibli.html#apue2e" id="id11">[APUE2e]</a> 的7.10节和10.15节。</td></tr>
</tbody>
</table>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre>int cond = 0; /* bool variable indicating error condition */
for (...) {
        for (...) {
                ...
                if (出现错误条件) {
                        cond = 1;
                        break;
                }
        }
        if (cond)
                break;
}
if (cond)
        出错处理;
</pre></div>
</td></tr></table></div>
<p>通常 <code class="docutils literal"><span class="pre">goto</span></code> 语句只用于这种场合，一个函数中任何地方出现了错误条件都可以立即跳转到函数末尾做出错处理（例如释放先前分配的资源、恢复先前改动过的全局变量等），处理完之后函数返回。比较用 <code class="docutils literal"><span class="pre">goto</span></code> 和不用 <code class="docutils literal"><span class="pre">goto</span></code> 的两种写法，用 <code class="docutils literal"><span class="pre">goto</span></code> 语句还是方便很多。但是除此之外，在任何其他场合都不要轻易考虑使用 <code class="docutils literal"><span class="pre">goto</span></code> 语句。有些编程语言（如C++）中有异常（Exception）处理的语法，可以代替 <code class="docutils literal"><span class="pre">goto</span></code> 和 <code class="docutils literal"><span class="pre">setjmp/longjmp</span></code> 的这种用法。</p>
<p id="index-9">回想一下我们在 <a class="reference internal" href="cond.html#cond-switch"><span>switch语句</span></a> 学过的语法， <code class="docutils literal"><span class="pre">case</span></code> 和 <code class="docutils literal"><span class="pre">default</span></code> 后面也要跟:号（Colon），事实上它们是两种特殊的标号。和标号有关的语法规则如下:</p>
<div class="highlight-python"><div class="highlight"><pre>语句 → 标识符: 语句
语句 → case 整型常量表达式: 语句
语句 → default: 语句
</pre></div>
</div>
<p>反复应用这些语法规则进行组合，可以在一条语句前面添加多个标号，例如在 <a class="reference internal" href="cond.html#cond-switch2"><span>缺break的switch语句</span></a> 的代码中，有些语句前面有多个 <code class="docutils literal"><span class="pre">case</span></code> 标号。现在我们再看 <code class="docutils literal"><span class="pre">switch</span></code> 语句的格式:</p>
<div class="highlight-python"><div class="highlight"><pre>switch (控制表达式) {
case 整型常量表达式： 零或多条语句
case 整型常量表达式： 零或多条语句
...
default： 零或多条语句
}
</pre></div>
</div>
<p>{}里面是一组语句列表，其中每个分支的第一条语句带有 <code class="docutils literal"><span class="pre">case</span></code> 或 <code class="docutils literal"><span class="pre">default</span></code> 标号，从语法上来说， <code class="docutils literal"><span class="pre">switch</span></code> 的语句块和其他分支、循环结构的语句块没有本质区别，因此前面的语法规则可以改写为:</p>
<div class="highlight-python"><div class="highlight"><pre>语句 → switch (控制表达式) 语句
语句 → { 语句列表 }
</pre></div>
</div>
<p>我们知道{}中的语句列表不仅可以包含语句，还可以包含声明，而先前的语法规则并没有体现出这一点，因此改写后的语法规则更为准确。但要注意，只有语句前面才能带标号，声明前面不能带标号，例如这样写是错的：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>但这样写是对的：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>这样写也是对的：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>再比如这样的 <code class="docutils literal"><span class="pre">switch</span></code> 语句：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">switch</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>这段代码从语法上看是对的，从语义上看却有一个陷阱。变量 <code class="docutils literal"><span class="pre">i</span></code> 在 <code class="docutils literal"><span class="pre">switch</span></code> 语句块中定义，但并不会初始化成10，因为不管 <code class="docutils literal"><span class="pre">n</span></code> 的值是几，进入 <code class="docutils literal"><span class="pre">switch</span></code> 语句块都会跳过给 <code class="docutils literal"><span class="pre">i</span></code> 做初始化的指令，从某一个 <code class="docutils literal"><span class="pre">case</span></code> 标号开始执行。</p>
<p class="rubric">习题</p>
<ol class="arabic">
<li><p class="first">以下代码编译没有问题，但运行结果却和预期不符（不能打印出 <code class="docutils literal"><span class="pre">other</span> <span class="pre">number</span></code> ），请分析原因。（提示：注意关键字的拼写）</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="nl">defau1t</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;other number</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">请在网上查找有关Duff&#8217;s Device的资料，Duff&#8217;s Device是一段很有意思的代码，正是利用“ <code class="docutils literal"><span class="pre">switch</span></code> 的语句块和循环结构的语句块没有本质区别”这一点实现了一个巧妙的代码优化。</p>
</li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. 循环语句</a><ul>
<li><a class="reference internal" href="#while">6.1. while语句</a></li>
<li><a class="reference internal" href="#do-while">6.2. do/while语句</a></li>
<li><a class="reference internal" href="#for">6.3. for语句</a></li>
<li><a class="reference internal" href="#breakcontinue">6.4. break和continue语句</a></li>
<li><a class="reference internal" href="#id8">6.5. 嵌套循环</a></li>
<li><a class="reference internal" href="#goto">6.6. goto语句和标号</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="func2.html"
                        title="previous chapter">5. 深入理解函数</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="struct.html"
                        title="next chapter">7. 结构体</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/zh/iter.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><table border=0 cellspacing=0 style="color: white;">
<script type="text/javascript">
  //<![CDATA[
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34437927-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
  //]]>
</script>
<tr><td>
   请输入您的email订阅<a href="http://groups.google.com/group/learning-linux-c-cpp">本书的邮件列表</a><br/>
   (Please enter your email to subscribe to <a href="http://groups.google.com/group/learning-linux-c-cpp">this book's mailing list</a>)<br/>
   <form action="http://groups.google.com/group/learning-linux-c-cpp/boxsubscribe"><input type=text name=email><input type=submit name="sub" value="订阅(Subscribe)"></form>
</td></tr>

<tr><td><br/>关注<a href="http://weibo.com/sansoong">我的微博</a></td></tr>

<tr><td><br/>Checkout the source from github: <a href="https://github.com/learning-linux-c-cpp/akabook">https://github.com/learning-linux-c-cpp/akabook</a></td></tr>

<tr><td>
   <br/>感谢您的慷慨捐赠！<br/>
   Thanks for your generous donation!<br/>
   <a href="http://me.alipay.com/songjinshan" target="_blank"><img src="/akabook/_static/me.alipay.png" alt="捐赠"></a>
</td></tr>
</table>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="struct.html" title="7. 结构体"
             >next</a> |</li>
        <li class="right" >
          <a href="func2.html" title="5. 深入理解函数"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">akabook 3.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >中文版：Linux C/C++编程一站式学习</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, Sean Soong.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>