
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>8. 数组 &mdash; akabook 3.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="akabook 3.0 documentation" href="../index.html" />
    <link rel="up" title="中文版：Linux C/C++编程一站式学习" href="index.html" />
    <link rel="next" title="9. 编码风格" href="codingstyle.html" />
    <link rel="prev" title="7. 结构体" href="struct.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="codingstyle.html" title="9. 编码风格"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="struct.html" title="7. 结构体"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">akabook 3.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">中文版：Linux C/C++编程一站式学习</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>8. 数组<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>8.1. 数组的基本概念<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p id="index-0">数组（Array）也是一种复合数据类型，它由一系列相同类型的元素（Element）组成。例如定义一个由4个 <code class="docutils literal"><span class="pre">int</span></code> 型元素组成的数组 <code class="docutils literal"><span class="pre">count</span></code> ：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</pre></div>
</td></tr></table></div>
<p>和结构体成员类似，数组 <code class="docutils literal"><span class="pre">count</span></code> 的4个元素的存储空间也是相邻的。结构体成员可以是基本数据类型，也可以是复合数据类型，数组中的元素也是如此。根据组合规则，我们可以定义一个由4个结构体元素组成的数组：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</pre></div>
</td></tr></table></div>
<p>也可以定义一个包含数组成员的结构体：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="n">s</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p id="index-1">数组类型的长度应该用一个整型常量表达式来指定 <a class="footnote-reference" href="#id4" id="id3">[1]</a> 。数组中的元素通过下标（或者叫索引，Index）来访问。例如前面定义的由4个 <code class="docutils literal"><span class="pre">int</span></code> 型元素组成的数组 <code class="docutils literal"><span class="pre">count</span></code> 图示如下：</p>
<span class="target" id="index-2"></span><table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>C99的新特性允许使用变量来定义数组的长度，称为变长数组（VLA，Variable Length Array），VLA只能定义为局部变量而不能是全局变量，与VLA有关的语法规则比较复杂，本书不做详细介绍。</td></tr>
</tbody>
</table>
<div class="figure" id="id18">
<img alt="../_images/array.count.png" src="../_images/array.count.png" />
<p class="caption"><span class="caption-text">数组count</span></p>
</div>
<p id="index-3">整个数组占了4个 <code class="docutils literal"><span class="pre">int</span></code> 型的存储单元，存储单元用小方框表示，里面的数字是存储在这个单元中的数据（假设都是0），而框外面的数字是下标，这4个单元分别用 <code class="docutils literal"><span class="pre">count[0]</span></code> 、 <code class="docutils literal"><span class="pre">count[1]</span></code> 、 <code class="docutils literal"><span class="pre">count[2]</span></code> 、 <code class="docutils literal"><span class="pre">count[3]</span></code> 来访问。注意，在定义数组 <code class="docutils literal"><span class="pre">int</span> <span class="pre">count[4];</span></code> 时，[]括号（Bracket）中的数字4表示数组的长度，而在访问数组时，[]括号中的数字表示访问数组的第几个元素。和我们平常数数不同，数组元素是从“第0个”开始数的，大多数编程语言都是这么规定的，所以计算机术语中有Zeroth这个词。这样规定使得访问数组元素非常方便，比如 <code class="docutils literal"><span class="pre">count</span></code> 数组中的每个元素占4个字节，则 <code class="docutils literal"><span class="pre">count[0]</span></code> 位于数组开头，而 <code class="docutils literal"><span class="pre">count[i]</span></code> 表示从数组开头跳过 <code class="docutils literal"><span class="pre">4*i</span></code> 个字节之后的那个存储单元。</p>
<p>这种数组下标的表达式不仅可以表示存储单元中的值，也可以表示存储单元本身，也就是说可以做左值，因此以下语句都是正确的：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="o">++</span><span class="n">count</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</td></tr></table></div>
<p>到目前为止我们学习了五种后缀运算符：后缀++、后缀&#8211;、结构体取成员.、数组取下标[]、函数调用()。还学习了五种单目运算符（或者叫前缀运算符）：前缀++、前缀&#8211;、正号+、负号-、逻辑非!。在C语言中后缀运算符的优先级最高，单目运算符的优先级仅次于后缀运算符，比其他运算符的优先级都高，所以上例中的 <code class="docutils literal"><span class="pre">++count[2]</span></code> 应该看作对 <code class="docutils literal"><span class="pre">count[2]</span></code> 做前缀++运算。</p>
<p>数组下标也可以是表达式，但表达式的值必须是整型的。例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</pre></div>
</td></tr></table></div>
<p>使用数组下标不能超出数组的长度范围，这一点在使用变量做数组下标时尤其要注意。C编译器并不检查 <code class="docutils literal"><span class="pre">count[-1]</span></code> 或是 <code class="docutils literal"><span class="pre">count[100]</span></code> 这样的访问越界错误，编译时能顺利通过，所以数组访问越界属于运行时错误 <a class="footnote-reference" href="#id6" id="id5">[2]</a> 。这种错误有时候很隐蔽，发生访问越界时程序可能并不会立即崩溃，而执行到后面某个正确的语句时却有可能突然崩溃（在 <a class="reference internal" href="gdb.html#gdb-segfault"><span>程序崩溃</span></a> 我们会看到这样的例子）。所以在写代码时要小心避免出这样的问题，事后依靠调试来解决问题的成本是很高的。</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td>你可能会想为什么编译器对这么明显的错误都视而不见？理由一，这种错误并不总是显而易见的，在 <a class="reference internal" href="pointer.html"><em>指针</em></a> 会讲到通过指针而不是数组名来访问数组的情况，指针指向数组中的什么位置只有运行时才知道，编译时无法检查是否越界，而运行时每次访问数组元素都检查越界会严重影响性能，所以干脆不检查了；理由二， <a class="reference internal" href="bibli.html#c99rationale" id="id7">[C99Rationale]</a> 的第0章指出，C语言的设计精神是：相信每个C程序员都是高手，不要阻止程序员去干他们需要干的事，在高手们写的代码中数组访问越界往往是一种技巧而不是Bug。此外，<strong class="command">gcc</strong> 的C语法扩展允许把数组长度定义为0，对这种数组的任何下标访问显然都是越界的，0长度的数组通常用作结构体的最后一个成员，详见 <a class="reference external" href="http://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html">http://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html</a> 。</td></tr>
</tbody>
</table>
<p>数组也可以像结构体一样初始化，未赋初值的元素也是用0来初始化，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>则 <code class="docutils literal"><span class="pre">count[0]</span></code> 等于3， <code class="docutils literal"><span class="pre">count[1]</span></code> 等于2，后面两个元素等于0。如果定义数组的同时初始化它，也可以不指定数组的长度，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">count</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>编译器会根据Initializer有三个元素确定数组的长度为3。利用C99的新特性也可以做Memberwise Initialization：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>下面看一个完整的例子：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">},</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;count[%d]=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p id="index-4">这个例子通过循环把数组中的每个元素依次访问一遍，在计算机术语中称为遍历（Traversal）。注意控制表达式 <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">4</span></code> ，如果写成 <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">4</span></code> 就错了，因为 <code class="docutils literal"><span class="pre">count[4]</span></code> 是访问越界。</p>
<p>数组和结构体虽然有很多相似之处，但也有一个显著的不同： <strong>数组不能相互赋值或初始化。</strong> 比如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="cm">/* WRONG! */</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>        <span class="cm">/* WRONG! */</span>
</pre></div>
</td></tr></table></div>
<p>用数组 <code class="docutils literal"><span class="pre">a</span></code> 来初始化数组 <code class="docutils literal"><span class="pre">b</span></code> 是错的，用数组 <code class="docutils literal"><span class="pre">a</span></code> 给数组 <code class="docutils literal"><span class="pre">b</span></code> 赋值也是错的。既然不能相互赋值，也就 <strong>不能用数组类型作为函数的参数或返回值</strong> 。如果写出这样的函数定义：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
<span class="p">{</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>然后这样调用：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="n">foo</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>编译器也不会报错，但这样写的意思并不是传一个数组类型的参数。对于数组类型有一条特殊的类型转换规则： <strong>数组类型做右值使用时，自动转换成指向数组首元素的指针。</strong> 对于函数声明也有一条特殊规则： <strong>在函数原型中，如果参数写成数组的形式，则该参数实际上是指针类型。</strong> 所以上面的函数调用其实是传一个指针类型的参数，而不是数组类型的参数。接下来的几章里有的函数需要访问数组，我们就把数组定义为全局变量给函数访问，等到 <a class="reference internal" href="pointer.html"><em>指针</em></a> 讲了指针再使用传参的办法。</p>
<p>数组类型不能相互赋值或初始化也是因为这条规则，例如上面提到的 <code class="docutils literal"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">a</span></code> 这个表达式， <code class="docutils literal"><span class="pre">a</span></code> 和 <code class="docutils literal"><span class="pre">b</span></code> 都是数组类型的变量， <code class="docutils literal"><span class="pre">a</span></code> 做右值使用自动转换成指针类型，而 <code class="docutils literal"><span class="pre">b</span></code> 做左值仍然是数组类型，把指针赋给数组是不行的，所以编译器报的错是 <code class="docutils literal"><span class="pre">error:</span> <span class="pre">incompatible</span> <span class="pre">types</span> <span class="pre">when</span> <span class="pre">assigning</span> <span class="pre">to</span> <span class="pre">type</span> <span class="pre">‘int[5]’</span> <span class="pre">from</span> <span class="pre">type</span> <span class="pre">‘int</span> <span class="pre">*’</span></code> 。</p>
<p class="rubric">习题</p>
<ol class="arabic simple">
<li>编写一个程序，定义两个类型和长度都相同的数组，将其中一个数组的所有元素拷贝给另一个。既然数组不能直接赋值，想想应该怎么实现。</li>
</ol>
</div>
<div class="section" id="array-statrandom">
<span id="id8"></span><h2>8.2. 数组应用实例：统计随机数<a class="headerlink" href="#array-statrandom" title="Permalink to this headline">¶</a></h2>
<p id="index-5">本节通过一个实例介绍使用数组的一些基本模式。问题是这样的：首先生成一列0~9的随机数保存在数组中，然后统计其中每个数字出现的次数并打印，检查这些数字的随机性如何。随机数在某些场合（例如游戏程序）是非常有用的，但是用计算机生成完全随机的数却不是那么容易。计算机执行每一条指令的结果都是确定的，没有一条指令产生的是随机数，调用C标准库函数得到的随机数其实是伪随机（Pseudorandom）数，是用数学公式算出来的确定的数，只不过这些数看起来很随机，并且从统计意义上也很接近于均匀分布（Uniform Distribution）的随机数。</p>
<p>C标准库中生成伪随机数的是 <code class="docutils literal"><span class="pre">rand</span></code> 函数，使用这个函数需要包含头文件 <code class="docutils literal"><span class="pre">stdlib.h</span></code> ，它没有参数，返回值是一个介于0和 <code class="docutils literal"><span class="pre">RAND_MAX</span></code> 之间的接近均匀分布的整数。 <code class="docutils literal"><span class="pre">RAND_MAX</span></code> 是该头文件中定义的一个常量，在不同的平台上有不同的取值，但可以肯定它是一个非常大的整数。通常我们用到的随机数是限定在某个范围之中的，例如0~9，而不是0~RAND_MAX，我们可以用%运算符将 <code class="docutils literal"><span class="pre">rand</span></code> 函数的返回值处理一下：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>完整的程序如下：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#define N 20</span>

<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">gen_random</span><span class="p">(</span><span class="kt">int</span> <span class="n">upper_bound</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">upper_bound</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_random</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">gen_random</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="n">print_random</span><span class="p">();</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p id="index-6">这里介绍一种新的预处理指示：用 <code class="docutils literal"><span class="pre">#define</span></code> 定义一个常量。实际上编译器的工作分为两个阶段，先是预处理（Preprocess）阶段，然后才是编译阶段，用 <strong class="command">gcc</strong> 的 <code class="xref std std-option docutils literal"><span class="pre">-E</span></code> 选项可以看到预处理之后、编译之前的程序，例如:</p>
<div class="highlight-python"><div class="highlight"><pre>$ gcc -E main.c
...（这里省略了很多行stdio.h和stdlib.h的代码）
int a[20];

void gen_random(int upper_bound)
{
        int i;
        for (i = 0; i &lt; 20; i++)
                a[i] = rand() % upper_bound;
}

void print_random()
{
        int i;
        for (i = 0; i &lt; 20; i++)
                printf(&quot;%d &quot;, a[i]);
        printf(&quot;\n&quot;);
}

int main(void)
{
        gen_random(10);
        print_random();
        return 0;
}
</pre></div>
</div>
<p>可见在这里预处理器做了两件事情，一是把头文件 <code class="docutils literal"><span class="pre">stdio.h</span></code> 和 <code class="docutils literal"><span class="pre">stdlib.h</span></code> 在代码中展开，二是把 <code class="docutils literal"><span class="pre">#define</span></code> 定义的标识符 <code class="docutils literal"><span class="pre">N</span></code> 替换成它的定义 <code class="docutils literal"><span class="pre">20</span></code> （在代码中做了三处替换，分别位于数组的定义中和两个函数中）。用 <strong class="command">cpp main.c</strong> 命令也可以达到同样的效果，只做预处理而不编译， <strong class="command">cpp</strong> 是C preprocessor的缩写。</p>
<p id="index-7">那么用 <code class="docutils literal"><span class="pre">#define</span></code> 定义的常量和 <a class="reference internal" href="struct.html#struct-typetag"><span>数据类型标志</span></a> 讲的枚举常量有什么区别呢？首先， <code class="docutils literal"><span class="pre">#define</span></code> 不仅用于定义常量，也可以定义更复杂的语法结构，称为宏（Macro）定义，我们将在 <a class="reference internal" href="prep.html"><em>预处理</em></a> 详细介绍。其次， <code class="docutils literal"><span class="pre">#define</span></code> 定义是在预处理阶段处理的，而枚举是在编译阶段处理的，试试看把 <a class="reference internal" href="struct.html#struct-typetag"><span>数据类型标志</span></a> 习题中的程序改成下面这样会是什么结果。</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#define RECTANGULAR 1</span>
<span class="cp">#define POLAR 2</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">RECTANGULAR</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">RECTANGULAR</span><span class="p">,</span> <span class="n">POLAR</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>注意，虽然 <code class="docutils literal"><span class="pre">include</span></code> 和 <code class="docutils literal"><span class="pre">define</span></code> 在预处理指示中有特殊含义，但它们并不是C语言的关键字，换句话说，它们也可以用作标识符，例如声明 <code class="docutils literal"><span class="pre">int</span> <span class="pre">include;</span></code> 或者 <code class="docutils literal"><span class="pre">void</span> <span class="pre">define(int);</span></code> 。在预处理阶段，如果一行以#号开头，后面跟 <code class="docutils literal"><span class="pre">include</span></code> 或 <code class="docutils literal"><span class="pre">define</span></code> ，预处理器就认为这是一条预处理指示，除此之外出现在其他地方的 <code class="docutils literal"><span class="pre">include</span></code> 或 <code class="docutils literal"><span class="pre">define</span></code> 预处理器并不关心，只当成普通的标识符留给编译阶段去处理。</p>
<p>回到随机数这个程序继续讨论，一开始为了便于分析和调试，我们取小一点的数组长度，只生成20个随机数，这个程序的运行结果为:</p>
<div class="highlight-python"><div class="highlight"><pre>3 6 7 5 3 5 6 2 9 1 2 7 0 9 3 6 0 6 2 6
</pre></div>
</div>
<p>看起来很随机了。但随机性如何呢？分布得均匀吗？所谓均匀分布，应该每个数出现的概率是一样的。在上面的20个结果中，6出现了5次，而4和8一次也没出现过。但这说明不了什么问题，毕竟我们的样本太少了，才20个数，如果样本足够多，比如说100000个数，统计一下其中每个数字出现的次数也许能说明问题。但总不能把100000个数都打印出来然后挨个去数吧？我们需要写一个函数统计每个数字出现的次数。完整的程序如下：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#define N 100000</span>

<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">gen_random</span><span class="p">(</span><span class="kt">int</span> <span class="n">upper_bound</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">upper_bound</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">howmany</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
                        <span class="o">++</span><span class="n">count</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">gen_random</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;value</span><span class="se">\t</span><span class="s">how many</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">howmany</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p id="index-8">我们只要把 <code class="docutils literal"><span class="pre">#define</span> <span class="pre">N</span></code> 的值改为 <code class="docutils literal"><span class="pre">100000</span></code> ，就相当于把整个程序中所有用到 <code class="docutils literal"><span class="pre">N</span></code> 的地方都改为 <code class="docutils literal"><span class="pre">100000</span></code> 了。如果我们不这么写，而是在定义数组时直接写成 <code class="docutils literal"><span class="pre">int</span> <span class="pre">a[20];</span></code> ，在每个循环中也直接使用 <code class="docutils literal"><span class="pre">20</span></code> 这个值，则称为硬编码（Hard Coding）。如果原来的代码是硬编码的，那么一旦需要把 <code class="docutils literal"><span class="pre">20</span></code> 改成 <code class="docutils literal"><span class="pre">100000</span></code> 就非常麻烦，你需要找遍整个代码，判断哪些 <code class="docutils literal"><span class="pre">20</span></code> 表示这个数组的长度就改为 <code class="docutils literal"><span class="pre">100000</span></code> ，哪些 <code class="docutils literal"><span class="pre">20</span></code> 表示别的数量则不做改动，如果代码很长，这是很容易出错的。所以， <strong>写代码时应尽可能避免硬编码</strong> ，这其实也是一个“提取公因式”的过程，和 <a class="reference internal" href="struct.html#struct-dataabstraction"><span>数据抽象</span></a> 讲的抽象具有相同的作用，就是尽量把一个改动局限在一个地方，避免这个改动波及大范围的代码。这个程序的运行结果如下:</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./a.out
value   how many
0       10130
1       10072
2       9990
3       9842
4       10174
5       9930
6       10059
7       9954
8       9891
9       9958
</pre></div>
</div>
<p>各数字出现的次数都在10000次左右，可见是比较均匀的。</p>
<p class="rubric">习题</p>
<ol class="arabic simple">
<li>用 <code class="docutils literal"><span class="pre">rand</span></code> 函数生成[10, 20]之间的随机整数，表达式应该怎么写？</li>
</ol>
</div>
<div class="section" id="id9">
<h2>8.3. 数组应用实例：直方图<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p id="index-9">继续上面的例子。我们统计一列0~9的随机数，打印每个数字出现的次数，像这样的统计结果称为直方图（Histogram）。有时候我们并不只是想打印，更想把统计结果保存下来以便做后续处理。我们可以把程序改成这样：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">howmanyones</span> <span class="o">=</span> <span class="n">howmany</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">howmanytwos</span> <span class="o">=</span> <span class="n">howmany</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>这显然太繁琐了。要是这样的随机数有100个呢？显然这里用数组最合适不过了：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">histogram</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

        <span class="n">gen_random</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">histogram</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">howmany</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>有意思的是，这里的循环变量 <code class="docutils literal"><span class="pre">i</span></code> 有两个作用，一是作为参数传给 <code class="docutils literal"><span class="pre">howmany</span></code> 函数，统计数字 <code class="docutils literal"><span class="pre">i</span></code> 出现的次数，二是做 <code class="docutils literal"><span class="pre">histogram</span></code> 的下标，也就是“把数字 <code class="docutils literal"><span class="pre">i</span></code> 出现的次数保存在数组 <code class="docutils literal"><span class="pre">histogram</span></code> 的第 <code class="docutils literal"><span class="pre">i</span></code> 个位置”。</p>
<p id="index-10">尽管上面的方法可以准确地得到统计结果，但是效率很低，这100000个随机数需要从头到尾检查十遍，每一遍检查只统计一种数字的出现次数。其实可以把 <code class="docutils literal"><span class="pre">histogram</span></code> 中的元素当作累加器来用，这些随机数只需要从头到尾检查一遍（Single Pass）就可以得出结果：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">histogram</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

        <span class="n">gen_random</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
                <span class="n">histogram</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>首先把 <code class="docutils literal"><span class="pre">histogram</span></code> 的所有元素初始化为0，注意使用局部变量的值之前一定要初始化，否则值是不确定的。接下来的代码很有意思，在每次循环中， <code class="docutils literal"><span class="pre">a[n]</span></code> 就是出现的随机数，而这个随机数同时也是 <code class="docutils literal"><span class="pre">histogram</span></code> 的下标，这个随机数每出现一次就把 <code class="docutils literal"><span class="pre">histogram</span></code> 中相应的元素加1。</p>
<p id="index-11">把上面的程序运行几遍，你就会发现每次产生的随机数都是一样的，不仅如此，在别的计算机上运行该程序产生的随机数很可能也是这样的。这正说明了这些数是伪随机数，是用一套确定的公式基于某个初值算出来的，只要初值相同，随后的整个数列就都相同。实际应用中不可能使用每次都一样的随机数，例如开发一个麻将游戏，每次运行这个游戏摸到的牌不应该是一样的。因此，C标准库允许我们自己指定一个初值，然后在此基础上生成伪随机数序列，这个初值称为Seed，可以用 <code class="docutils literal"><span class="pre">srand</span></code> 函数指定Seed。通常我们通过别的途径得到一个不确定的数作为Seed，例如调用 <em class="manpage">time(2)</em> 函数得到当前系统时间距1970年1月1日00:00:00 <a class="footnote-reference" href="#id11" id="id10">[3]</a> 的秒数，然后传给 <code class="docutils literal"><span class="pre">srand</span></code> ：</p>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[3]</a></td><td>各种派生自UNIX的系统都把这个时刻称为Epoch，因为这个时刻近似等于UNIX系统诞生的时间（实际上最早的UNIX系统诞生于1969年）。</td></tr>
</tbody>
</table>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
</pre></div>
</td></tr></table></div>
<p>然后再调用 <code class="docutils literal"><span class="pre">rand</span></code> ，得到的随机数就和刚才完全不同了。调用 <em class="manpage">time(2)</em> 函数需要包含头文件 <code class="file docutils literal"><span class="pre">time.h</span></code> ，这里的 <code class="docutils literal"><span class="pre">NULL</span></code> 表示空指针，到 <a class="reference internal" href="pointer.html#pointer-pointer"><span>指针的基本概念</span></a> 再详细解释。</p>
<p class="rubric">习题</p>
<ol class="arabic">
<li><p class="first">补完本节直方图程序的 <code class="docutils literal"><span class="pre">main</span></code> 函数，以可视化的形式打印直方图。例如上一节统计20个随机数的结果是:</p>
<div class="highlight-python"><div class="highlight"><pre>0  1  2  3  4  5  6  7  8  9

*  *  *  *     *  *  *     *
*     *  *     *  *  *     *
      *  *        *
                  *
                  *
</pre></div>
</div>
</li>
<li><p class="first">用数组定义一个序列，编程打印它的全排列。比如定义：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#define N 3</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>则运行结果是:</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./a.out
1 2 3
1 3 2
2 1 3
2 3 1
3 2 1
3 1 2
</pre></div>
</div>
<p>程序的主要思路是：</p>
<ol class="arabic simple">
<li>把第1个数换到最前面来（和第1个数交换，其实就是自己和自己交换，序列不变，还是1，2，3），准备打印1xx，再对后两个数2和3做全排列，打印完所有排列后恢复序列原来的次序。</li>
<li>把第2个数换到最前面来（和第1个数交换，序列变成2，1，3），准备打印2xx，再对后两个数1和3做全排列，打印完所有排列后恢复序列原来的次序。</li>
<li>把第3个数换到最前面来（和第1个数交换，序列变成3，2，1），准备打印3xx，再对后两个数2和1做全排列，打印完所有排列后恢复序列原来的次序。</li>
</ol>
<p>可见这是一个递归的过程，把“对整个序列做全排列”的问题归结为“对它的子序列做全排列”的问题，注意我没有描述Base Case怎么处理，你需要自己想。你的程序要具有通用性，如果改变了 <code class="docutils literal"><span class="pre">N</span></code> 和数组 <code class="docutils literal"><span class="pre">a</span></code> 的定义（比如改成4个数的数组），其他代码不需要修改就可以做4个数的全排列（共24种排列）。</p>
<p>完成了上述要求之后再考虑第二个问题：如果再定义一个常量 <code class="docutils literal"><span class="pre">M</span></code> 表示从 <code class="docutils literal"><span class="pre">N</span></code> 个数中取 <code class="docutils literal"><span class="pre">M</span></code> 个数做排列（ <code class="docutils literal"><span class="pre">N</span> <span class="pre">==</span> <span class="pre">M</span></code> 时表示全排列），原来的程序应该怎么改？</p>
<p>最后再考虑第三个问题：如果要求从 <code class="docutils literal"><span class="pre">N</span></code> 个数中取 <code class="docutils literal"><span class="pre">M</span></code> 个数做组合而不是做排列，就不能用原来的递归过程了，想想组合的递归过程应该怎么描述，编程实现它。</p>
</li>
</ol>
</div>
<div class="section" id="id12">
<h2>8.4. 字符串<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>之前我一直对字符串避而不谈，不做详细解释，现在已经具备了必要的基础知识，可以深入讨论一下字符串了。字符串字面值和数组类型相似，它的每个元素是字符型的，例如字符串 <code class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">world.\n&quot;</span></code> 图示如下：</p>
<div class="figure" id="id19">
<img alt="../_images/array.string.png" src="../_images/array.string.png" />
<p class="caption"><span class="caption-text">字符串</span></p>
</div>
<p id="index-12">注意每个字符串末尾都有一个字符 <code class="docutils literal"><span class="pre">'\0'</span></code> 做结束符，在 <a class="reference internal" href="expr.html#expr-char"><span>字符类型与字符编码</span></a> 讲过 <code class="docutils literal"><span class="pre">'\0'</span></code> 叫Null字符，所以字符串也称为“以Null结尾的字符串”（Null-terminated String）。</p>
<p>数组元素可以通过数组名加下标的方式访问，而字符串字面值也可以像数组名一样使用，可以加下标访问其中的字符，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="s">&quot;Hello, world.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>
</pre></div>
</td></tr></table></div>
<p>把 <code class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">world.\n&quot;</span></code> 这个字符串看作一个数组，下标14的位置是字符 <code class="docutils literal"><span class="pre">'\0'</span></code> ，所以这个语句把 <code class="docutils literal"><span class="pre">'\0'</span></code> 赋给了变量 <code class="docutils literal"><span class="pre">c</span></code> 。C标准没有规定字符串字面值所占的存储空间是否允许被修改，但常见的C编译器都把字符串字面值实现成只读的。假如代码中有这么一行：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="s">&quot;Hello, world.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><strong class="command">gcc</strong> 在编译时会给出一个警告 <code class="docutils literal"><span class="pre">warning:</span> <span class="pre">assignment</span> <span class="pre">of</span> <span class="pre">read-only</span> <span class="pre">location</span></code> ，在运行时程序执行到这一条语句会产生段错误。</p>
<p>字符串字面值还有一点和数组类型相似：做右值使用时自动转换成指向首字符的指针。在 <a class="reference internal" href="func.html#func-parameter"><span>形参和实参</span></a> 我们看到 <code class="docutils literal"><span class="pre">printf</span></code> 原型的第一个参数是指向字符的指针类型，而函数调用 <code class="docutils literal"><span class="pre">printf(&quot;Hello,</span> <span class="pre">world.\n&quot;)</span></code> 其实就是传一个指针参数给 <code class="docutils literal"><span class="pre">printf</span></code> ，关于字符串字面值和指针的关系将在 <a class="reference internal" href="pointer.html#pointer-pointertoconst"><span>指针与const限定符</span></a> 详细解释。字符串字面值有一种特殊用法，可以作为Initializer给一个字符数组初始化 <a class="footnote-reference" href="#id14" id="id13">[4]</a> ：</p>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[4]</a></td><td>这个语法的特殊之处在于，在这里字符串字面值和数组的用法并不相似，我们不能用一个数组给另一个数组初始化，却可以用一个字符串字面值给一个数组初始化。另一方面，我们不能把一个数组赋值给另一个数组，同样也不能把一个字符串字面值赋值给一个数组。这些特殊规定没什么道理可讲，一切都可归结于历史原因。</td></tr>
</tbody>
</table>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>等价于这样初始化：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;H&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p><code class="docutils literal"><span class="pre">str</span></code> 的后4个元素没有指定，自动初始化为Null字符。注意，虽然字符串字面值 <code class="docutils literal"><span class="pre">&quot;Hello&quot;</span></code> 是只读的，但用它初始化的数组 <code class="docutils literal"><span class="pre">str</span></code> 却是可读可写的，这说明 <code class="docutils literal"><span class="pre">str</span></code> 和 <code class="docutils literal"><span class="pre">&quot;Hello&quot;</span></code> 各自占据不同的存储空间，只不过 <code class="docutils literal"><span class="pre">str</span></code> 所占的存储空间里的内容拷贝自 <code class="docutils literal"><span class="pre">&quot;Hello&quot;</span></code> 。数组 <code class="docutils literal"><span class="pre">str</span></code> 中保存了一串字符，以Null字符结尾，也可以叫字符串。 <strong>在本书中只要是以Null结尾的一串字符都叫字符串，不管是像str这样的字符数组，还是像&#8221;Hello&#8221;这样的字符串字面值。</strong></p>
<p>如果用于初始化的字符串字面值比数组还长，比如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Hello, world.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>则数组 <code class="docutils literal"><span class="pre">str</span></code> 只包含字符串的前10个字符，不包含Null字符，这种情况编译器会给出警告。如果要用一个字符串字面值准确地初始化一个字符数组，最好的办法是不指定数组的长度，让编译器自己计算：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello, world.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>字符串字面值的长度包括Null字符在内一共15个字符，编译器会确定数组 <code class="docutils literal"><span class="pre">str</span></code> 的长度为15。有一种情况需要特别注意，如果用于初始化的字符串字面值比数组刚好长出一个Null字符的长度，比如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Hello, world.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>则数组 <code class="docutils literal"><span class="pre">str</span></code> 不包含Null字符，并且编译器不会给出警告， <a class="reference internal" href="bibli.html#c99rationale" id="id15">[C99Rationale]</a> 的6.7.8节说这样规定是为了程序员方便，以前的很多编译器也都是这样实现的，不管它有理没理，C标准既然这么规定了我们也没办法，只能自己小心了。</p>
<p>补充一点，在 <code class="docutils literal"><span class="pre">printf</span></code> 函数的格式化字符串中可以用 <code class="docutils literal"><span class="pre">%s</span></code> 表示字符串的占位符。在学习字符数组以前，我们用 <code class="docutils literal"><span class="pre">%s</span></code> 没什么意义，因为</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">printf</span><span class="p">(</span><span class="s">&quot;string: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;Hello&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>还不如写成</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">printf</span><span class="p">(</span><span class="s">&quot;string: Hello</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>但现在字符串可以保存在一个数组里面，用 <code class="docutils literal"><span class="pre">%s</span></code> 来打印就很有必要了：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">printf</span><span class="p">(</span><span class="s">&quot;string: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><code class="docutils literal"><span class="pre">printf</span></code> 会从数组 <code class="docutils literal"><span class="pre">str</span></code> 的开头一直打印到Null字符为止，Null字符本身是Non-printable字符，不打印。这其实是一个危险的信号：如果数组 <code class="docutils literal"><span class="pre">str</span></code> 中没有Null字符，那么 <code class="docutils literal"><span class="pre">printf</span></code> 函数就会访问数组越界，后果可能会很诡异，有时候打印出乱码，有时候看起来没错误，有时候引起程序崩溃。</p>
</div>
<div class="section" id="array-multidim">
<span id="id16"></span><h2>8.5. 多维数组<a class="headerlink" href="#array-multidim" title="Permalink to this headline">¶</a></h2>
<p id="index-13">就像结构体可以嵌套一样，数组也可以嵌套，一个数组的元素可以是另外一个数组，这样就构成了多维数组（Multi-dimensional Array）。例如定义并初始化一个二维数组：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>数组 <code class="docutils literal"><span class="pre">a</span></code> 有3个元素， <code class="docutils literal"><span class="pre">a[0]</span></code> 、 <code class="docutils literal"><span class="pre">a[1]</span></code> 、 <code class="docutils literal"><span class="pre">a[2]</span></code> 。每个元素也是一个数组，例如 <code class="docutils literal"><span class="pre">a[0]</span></code> 是一个数组，它有两个元素 <code class="docutils literal"><span class="pre">a[0][0]</span></code> 、 <code class="docutils literal"><span class="pre">a[0][1]</span></code> ，这两个元素的类型是 <code class="docutils literal"><span class="pre">int</span></code> ，值分别是1、2，同理，数组 <code class="docutils literal"><span class="pre">a[1]</span></code> 的两个元素是3、4，数组 <code class="docutils literal"><span class="pre">a[2]</span></code> 的两个元素是5、0。如下图所示：</p>
<div class="figure" id="id20">
<img alt="../_images/array.multidim.png" src="../_images/array.multidim.png" />
<p class="caption"><span class="caption-text">多维数组</span></p>
</div>
<p id="index-14">从概念模型上看，这个二维数组是三行两列的表格，元素的两个下标分别是行号和列号。从物理模型上看，这六个元素在存储器中仍然是连续存储的，就像一维数组一样，相当于把概念模型的表格一行一行接起来拼成一串，C语言的这种存储方式称为Row-major方式，而有些编程语言（例如FORTRAN）是把概念模型的表格一列一列接起来拼成一串存储的，称为Column-major方式。</p>
<p>多维数组也可以像嵌套结构体一样用嵌套Initializer初始化，例如上面的二维数组也可以这样初始化：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">5</span><span class="p">,</span> <span class="p">}</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>利用C99的新特性也可以做Memberwise Initialization，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>结构体和数组嵌套的情况也可以做Memberwise Initialization，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="mf">8.0</span> <span class="p">};</span>

<span class="k">struct</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>如果是多维字符数组，也可以嵌套使用字符串字面值做Initializer，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">print_day</span><span class="p">(</span><span class="kt">int</span> <span class="n">day</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">char</span> <span class="n">days</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;Monday&quot;</span><span class="p">,</span> <span class="s">&quot;Tuesday&quot;</span><span class="p">,</span>
                             <span class="s">&quot;Wednesday&quot;</span><span class="p">,</span> <span class="s">&quot;Thursday&quot;</span><span class="p">,</span> <span class="s">&quot;Friday&quot;</span><span class="p">,</span>
                             <span class="s">&quot;Saturday&quot;</span><span class="p">,</span> <span class="s">&quot;Sunday&quot;</span> <span class="p">};</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">day</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">day</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">days</span><span class="p">[</span><span class="n">day</span><span class="p">]);</span>
        <span class="k">else</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Illegal day number!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">print_day</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="figure" id="id21">
<img alt="../_images/array.multichar.png" src="../_images/array.multichar.png" />
<p class="caption"><span class="caption-text">多维字符数组</span></p>
</div>
<p>这个程序中定义了一个多维字符数组 <code class="docutils literal"><span class="pre">char</span> <span class="pre">days[8][10];</span></code> ，如上图所示。为了使1~7刚好映射到 <code class="docutils literal"><span class="pre">days[1]</span></code> ~ <code class="docutils literal"><span class="pre">days[7]</span></code> ，我们把 <code class="docutils literal"><span class="pre">days[0]</span></code> 空出来不用，所以第一维的长度是8，为了使最长的字符串 <code class="docutils literal"><span class="pre">&quot;Wednesday&quot;</span></code> 能够保存到一行，末尾还能多出一个Null字符的位置，所以第二维的长度是10。</p>
<p id="index-15">这个程序和 <a class="reference internal" href="cond.html#cond-switch1"><span>switch语句</span></a> 的功能其实是一样的，但是代码简洁多了。简洁的代码不仅可读性强，而且维护成本也低，像 <a class="reference internal" href="cond.html#cond-switch1"><span>switch语句</span></a> 那样一堆 <code class="docutils literal"><span class="pre">case</span></code> 、 <code class="docutils literal"><span class="pre">printf</span></code> 和 <code class="docutils literal"><span class="pre">break</span></code> ，如果漏写一个 <code class="docutils literal"><span class="pre">break</span></code> 就要出Bug。这个程序之所以简洁，是因为用数据代替了代码。具体来说，通过下标访问字符串组成的数组可以代替一堆 <code class="docutils literal"><span class="pre">case</span></code> 分支判断，这样就可以把每个 <code class="docutils literal"><span class="pre">case</span></code> 里重复的代码（ <code class="docutils literal"><span class="pre">printf</span></code> 调用）提取出来，从而又一次达到了“提取公因式”的效果。这种方法称为数据驱动的编程（Data-driven Programming），写代码最重要的是选择正确的数据结构来组织信息，设计控制流程和算法尚在其次，只要数据结构选择得正确，其他代码自然而然就变得容易理解和维护了，就像这里的 <code class="docutils literal"><span class="pre">printf</span></code> 自然而然就被提取出来了。 <a class="reference internal" href="bibli.html#id3" id="id17">[人月神话]</a> 的第9章说：“Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won&#8217;t usually need your flowcharts; they&#8217;ll be obvious.”</p>
<p>最后，综合本章的知识，我们来写一个最简单的小游戏－－剪刀石头布：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">char</span> <span class="n">gesture</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;scissor&quot;</span><span class="p">,</span> <span class="s">&quot;stone&quot;</span><span class="p">,</span> <span class="s">&quot;cloth&quot;</span> <span class="p">};</span>
        <span class="kt">int</span> <span class="n">man</span><span class="p">,</span> <span class="n">computer</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

        <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">computer</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Input your gesture (0-scissor 1-stone 2-cloth):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">man</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">man</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">man</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Invalid input!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;You: %s</span><span class="se">\t</span><span class="s">Computer: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                       <span class="n">gesture</span><span class="p">[</span><span class="n">man</span><span class="p">],</span> <span class="n">gesture</span><span class="p">[</span><span class="n">computer</span><span class="p">]);</span>

                <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">man</span> <span class="o">-</span> <span class="n">computer</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;You win!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Draw!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                <span class="k">else</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;You lose!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>0、1、2三个整数分别是剪刀、石头、布在程序中的内部表示，用户也要求输入0、1或2，然后和计算机随机生成的0、1或2比胜负。这个程序的主体是一个死循环，需要按Ctrl-C退出程序。以往我们写的程序都只有打印输出，在这个程序中我们第一次碰到处理键盘输入的情况。我们简单介绍一下 <code class="docutils literal"><span class="pre">scanf</span></code> 函数的用法，到 <a class="reference internal" href="stdlib.html#stdlib-formattedio"><span>格式化I/O函数</span></a> 再详细解释。</p>
<p><code class="docutils literal"><span class="pre">scanf(&quot;%d&quot;,</span> <span class="pre">&amp;man)</span></code> 这个调用的功能是等待用户输入一个整数并回车，这个整数会被 <code class="docutils literal"><span class="pre">scanf</span></code> 函数保存在 <code class="docutils literal"><span class="pre">man</span></code> 这个整型变量里。如果用户输入合法（输入的确实是数字而不是别的字符），则 <code class="docutils literal"><span class="pre">scanf</span></code> 函数返回1，表示成功读入一个数据。但即使用户输入的是整数，我们还需要进一步检查是不是在0~2的范围内，写程序处理用户输入时要格外小心，用户有可能输入任何数据，他才不管游戏规则是什么。</p>
<p>和 <code class="docutils literal"><span class="pre">printf</span></code> 类似， <code class="docutils literal"><span class="pre">scanf</span></code> 也可以用 <code class="docutils literal"><span class="pre">%c</span></code> 、 <code class="docutils literal"><span class="pre">%f</span></code> 、 <code class="docutils literal"><span class="pre">%s</span></code> 等转换说明。如果在传给 <code class="docutils literal"><span class="pre">scanf</span></code> 的第一个参数中用 <code class="docutils literal"><span class="pre">%d</span></code> 、 <code class="docutils literal"><span class="pre">%f</span></code> 或 <code class="docutils literal"><span class="pre">%c</span></code> 表示读入一个整数、浮点数或字符，则第二个参数的形式应该是&amp;运算符加相应类型的变量名，表示读进来的数保存到这个变量中，&amp;运算符的作用是取变量存储空间的地址得到一个指针类型，到 <a class="reference internal" href="pointer.html#pointer-pointer"><span>指针的基本概念</span></a> 再详细解释。如果在第一个参数中用 <code class="docutils literal"><span class="pre">%s</span></code> 读入一个字符串，则第二个参数应该是数组名，数组名前面不加&amp;，因为数组类型做右值时自动转换成指针类型，在 <a class="reference internal" href="gdb.html#gdb-breakpoint"><span>断点</span></a> 有 <code class="docutils literal"><span class="pre">scanf</span></code> 读入字符串的例子。</p>
<p>留给读者思考的问题是： <code class="docutils literal"><span class="pre">(man</span> <span class="pre">-</span> <span class="pre">computer</span> <span class="pre">+</span> <span class="pre">4)</span> <span class="pre">%</span> <span class="pre">3</span> <span class="pre">-</span> <span class="pre">1</span></code> 这个神奇的表达式是如何比较出0、1、2这三个数字在“剪刀石头布”意义上的大小的？</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">8. 数组</a><ul>
<li><a class="reference internal" href="#id2">8.1. 数组的基本概念</a></li>
<li><a class="reference internal" href="#array-statrandom">8.2. 数组应用实例：统计随机数</a></li>
<li><a class="reference internal" href="#id9">8.3. 数组应用实例：直方图</a></li>
<li><a class="reference internal" href="#id12">8.4. 字符串</a></li>
<li><a class="reference internal" href="#array-multidim">8.5. 多维数组</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="struct.html"
                        title="previous chapter">7. 结构体</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="codingstyle.html"
                        title="next chapter">9. 编码风格</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/zh/array.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><table border=0 cellspacing=0 style="color: white;">
<script type="text/javascript">
  //<![CDATA[
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34437927-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
  //]]>
</script>
<tr><td>
   请输入您的email订阅<a href="http://groups.google.com/group/learning-linux-c-cpp">本书的邮件列表</a><br/>
   (Please enter your email to subscribe to <a href="http://groups.google.com/group/learning-linux-c-cpp">this book's mailing list</a>)<br/>
   <form action="http://groups.google.com/group/learning-linux-c-cpp/boxsubscribe"><input type=text name=email><input type=submit name="sub" value="订阅(Subscribe)"></form>
</td></tr>

<tr><td><br/>关注<a href="http://weibo.com/sansoong">我的微博</a></td></tr>

<tr><td><br/>Checkout the source from github: <a href="https://github.com/learning-linux-c-cpp/akabook">https://github.com/learning-linux-c-cpp/akabook</a></td></tr>

<tr><td>
   <br/>感谢您的慷慨捐赠！<br/>
   Thanks for your generous donation!<br/>
   <a href="http://me.alipay.com/songjinshan" target="_blank"><img src="/akabook/_static/me.alipay.png" alt="捐赠"></a>
</td></tr>
</table>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="codingstyle.html" title="9. 编码风格"
             >next</a> |</li>
        <li class="right" >
          <a href="struct.html" title="7. 结构体"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">akabook 3.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >中文版：Linux C/C++编程一站式学习</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, Sean Soong.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>